%Documentation for Final project
%Language:‌ Persian
\documentclass[oneside]{report}
   \usepackage[
   left = 2.5cm ,
   right = 3.5cm,
   bottom = 2.5cm,
   ]{geometry}
\usepackage{titlesec}
\usepackage{subfigure}
%\usepackage[perpage]{footmisc}

\usepackage[extrafootnotefeatures]{xepersian}

\settextfont{B Nazanin}
\linespread{1.3}
\setlength{\skip\footins}{2cm}
\setlength{\footnotesep}{0.3cm}

\setcounter{secnumdepth}{4}%bound for subsections
\setcounter{tocdepth}{4}

\titleformat{\chapter}[display]
	{\normalfont\Huge\bfseries\centering}
	{\chaptertitlename \thechapter}{20pt}{\Huge\bfseries}
\setlatintextfont{Georgia}

\begin{document}
 \newcounter{MyC}
\newcommand\addHarfi{\harfi{MyC}\addtocounter{MyC}{1}\ }
\setcounter{MyC}{1}
\pagenumbering{harfi}

\begin{figure}[h]
	\centering
	\includegraphics[height=10cm]{image2/besm}
	\label{fig:besm}
\end{figure}

\newpage
\newgeometry{   bottom = 1.5cm ,top = 2cm ,left=2.5cm,right=2.5cm}
\begin{figure}
	\centering
	\includegraphics[height=3cm]{image2/uniicon}
	\label{fig:uniicon}
\end{figure}

\begin{center}
	
	\textbf{\huge دانشکده‌ی مهندسی برق و کامپیوتر}

\vspace*{1cm}	

	\textbf{\Huge پایان‌نامه‌ی کارشناسی مهندسی کامپیوتر-نرم‌افزار}

\vspace*{2cm}

	\textbf{\Huge تحلیل فنی پرداخت مبتنی بر کیف پول الکترونیکی و }
	
	\vspace*{0.5cm}
	
	\textbf{\Huge طراحی و پیاده‌سازی نمونه‌ای از پرداخت}

\vspace*{2cm}
	
\textbf{\LARGE نگارش:}

\vspace*{0.5cm}

	\textbf{\Huge محمد‌حسام مدبری}

\vspace*{2cm}

	\textbf{\LARGE استاد راهنما:}
	
	\vspace*{0.5cm}
	
		\textbf{\Huge  دکتر مرتضی دری‌گیو}
	
	\vspace*{4cm}
	
			\textbf{\Huge  بهمن-۱۳۹۵}
	
\end{center}

\newpage

\begin{figure}[h]
	\centering
	\includegraphics[height=12cm]{image2/taaahod}
	\label{fig:taaahod}
\end{figure}


\newpage

\begin{figure}[h]
	\centering
	\includegraphics[height=3cm]{image2/uniicon}
\end{figure}

\begin{center}
	{\LARGE دانشکده‌ی مهندسی برق و کامپیوتر}
	
	\vspace*{1.5cm}
	
	{\LARGE تأیید دفاع از پایان‌نامه‌ی کارشناسی}
	
	\vspace*{0.5cm}
	
	{\LARGE پایان‌نامه‌ی}
	\textbf{\LARGE محمد‌حسام مدبری}
	
	\vspace*{1.5cm}
	
	{\LARGE برای اخذ درجه‌ی }
	\textbf{\LARGE کارشناسی مهندسی کامپیوتر-نرم‌افزار}
	
	\vspace*{1.2cm}
	
	{\LARGE با عنوان: }
	
\vspace*{1cm}
	
	\textbf{\huge تحلیل فنی پرداخت مبتنی بر کیف پول الکترونیکی و}
	
	\vspace*{0.4cm}
	
	\textbf{\huge پیاده‌سازی نمونه‌ای از پرداخت}
	
	\vspace*{1cm}
	
	{\LARGE در تاریخ ... }
	\textbf{\LARGE بهمن ۱۳۹۵}
	{\LARGE دفاع شد و مورد تأیید قرار گرفت.}
	
	\vspace*{1.7cm}
	
	{\LARGE تأییدکنندگان:}
	
	\vspace*{0.7cm}
	
	{\LARGE  ۱) استاد محترم داور...........................................................................امضا}

		\vspace*{0.7cm}
		
	{\LARGE ۲) استاد محترم راهنما.......................................................................امضا}
		
			\vspace*{0.7cm}
	
	{\LARGE ۳) مدیر محترم گروه کامپیوتر...........................................................امضا}
	
\end{center}

\newpage


\restoregeometry
\linespread{1.3}
 \section*{چکیده}
\Large \noindent
با توجه به مشکلات امنیتی موجود در زمینه‌ی پرداخت الکترونیکی،‌ استفاده از راه‌حل‌ کیف پول الکترونیکی به منظور رفع این مشکلات حائز اهمیت است. به سبب اینکه پرداخت‌های امروزی، اطلاعات کارت بانکی را در معرض خطر قرار می‌دهند، پنهان بودن اطلاعات پرداخت و امن‌تر کردن تراکنش‌ها به علاوه‌ی سهولت پرداخت، از هداف اصلی کیف پول ‌الکترونیکی می‌باشد.

\noindent
در فصل‌های ابتدایی تکنولوژی‌
	{\normalsize \lr	{Tokenisation}}
مورد مطالعه قرار خواهد گرفت که نقش اصلی در ایمن‌سازی کیف‌پول‌های الکترونیکی را دارد. در باقی فصل‌ها به بررسی بخش‌های مختلف پروژه‌ی پیاده‌سازی شده پرداخته می‌شود.

\noindent
پروژه‌ی انجام شده، پیاده‌سازی مدلی از پرداخت است که با کمک تکنولوژی
{\normalsize \lr {iBeacon}}
اپل به منظور پیدا کردن موقعیت کاربر مورد استفاده قرار گرفته است.


\vspace*{1cm}
\noindent
\textbf{کلید واژگان: } 
{\large \lr	{Tokenisation}} ، {\large \lr {iBeacon}} ، پرداخت الکترونیک ، کیف‌پول الکترونیکی

%\pagenumbering{gobble}
{\let\cleardoublepage\clearpage 
	\tableofcontents
}
	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	\chapter{مقدمه}\label{introduction}
		\pagenumbering{arabic}
		امروزه اکثر خرید‌ها و به موجب آن پرداخت‌ها از طریق کارت‌های بانکی صورت می‌گیرد، به همین خاطر توجه سارقان و کلاهبرداران این حوزه را به خود جلب کرده است. سرویس‌های کیف‌پول الکترونیکی این اجازه را به کاربران می‌دهند که کارت‌های بانکی خود را بصورت دیجیتالی در دستگاه‌های دیجیتالی مانند تلفن‌های هوشمند ذخیره کنند. بدین طریق کاربران در زمان پرداخت به جای استفاده از کارت‌های بانکی حقیقی از کارت دیجیتالی ذخیره شده بر روی دستگاه دیجیتالی‌شان استفاده می‌کنند. تدابیر امنیتی مناسبی برای ایمن کردن اینگونه پرداخت‌ها دیده شده که  مهم‌ترین آن‌ها تکنولوژی  {\normalsize \lr	{Tokenisation}}  می‌باشد. در فصل \ref{tokenisation} به توضیح این تکنولوژی پرداخته خواهد شد.
		
		برای خرید یک کالا و یا یک سرویس مدل‌های مختلفی وجود دارد که کاربران می‌توانند با استفاده از آن‌ها پرداخت را انجام دهند. برای مثال کاربران می‌توانند خریدهایشان را از راه ترمینال‌های مجهز به تکنولوژی 
			{\normalsize \lr	{NFC}}
		\LTRfootnote{Near Field Communication}
		به صورت پرداخت غیرتماسی \LTRfootnote{Contacltess payment}،   و یا از راه نرم‌افزار‌های پرداخت به راه‌های مختلف انجام دهند. در ادامه‌ی این فصل به چند نمونه از مدل‌های پرداخت که در حال حاضر موجود هستند، خواهیم پرداخت.		
			  
			  لازم به ذکر است، کیف پول الکترونیکی که به منظور نگهداری بیت کوین‌ها
			  \LTRfootnote{Bitcoin}
			  و یا پول الکترونیکی می‌باشد، مورد بحث نخواهد بود.
			  
				\section{معرفی سرویس‌های برجسته‌ی کیف پول الکترونیکی }
		
		از جمله‌ی سرویس‌های کیف‌پول، می‌توان 
				{\normalsize \lr{Apple Pay}} 
		را نام برد که اپل در ماه سپتامبر ۲۰۱۴ با معرفی 
				{\normalsize \lr{iPhone 6}} 
		آن را عرضه کرد.	شرکت گوگل نیز سرویس 
						{\normalsize \lr{Android Pay}} 
		را در ماه فوریه‌ی ۲۰۱۵ معرفی کرد. سرویس‌های کیف‌پولی که این شرکت‌ها ارائه کرده‌اند، بر پایه‌ی تکنولوژی 
			{\normalsize \lr	{Tokenisation}}
			می‌باشند، و از این تکنولوژی برای مدیریت کارت‌های بانکی استفاده می‌کنند. لازم به ذکر است که سرویس 
						{\normalsize \lr{Apple Pay}} 
						به عنوان امن‌ترین روش پرداخت موجود در جهان شناخته شده است 
						\cite{mostsecureBellID}.
						بنابراین در ادامه تمرکز بیشتر بر روی توضیح سرویس
							 									 {\normalsize \lr{Apple Pay}}
							 									 خواهد بود، از لحاظ رابط کاربری تفاوت چشم‌گیری با یکدیگر ندارند، اما از لحاظ فنی جای بحث خواهد داشت.
			در فصل \ref{comparison} به مقایسه‌ی دو سرویس ارائه شده توسط این دو شرکت  و علت برتری سرویس
										{\normalsize \lr{Apple Pay}} 
			پرداخته خواهد شد.
		
		\subsection{ سرویس {\normalsize\lr{Apple Pay}}}
		برای استفاده از سرویس 
								{\normalsize \lr{Apple Pay}} 
								از نرم‌افزار
														{\normalsize \lr{Wallet}} 
		که بصورت پیش‌فرض بر روی دستگاه‌های
								{\normalsize \lr{iPhone 6}} 
								و مدل‌های بالاتر و
						{\normalsize \lr{Apple Watch}} 
								 نصب شده است،	 استفاده می‌شود. شکل  
								 \ref{wallet-image}
								 آیکون نرم‌افزار
							 										{\normalsize \lr{Wallet}} 
را نشان می‌دهد.
								 
		\begin{figure}[h]
			\centering
			\includegraphics[height=1.5cm]{images/apple-wallet-image}
			\caption{آیکون نرم‌افزار {\footnotesize \lr{Wallet}} }
			\label{wallet-image}
		\end{figure}
	\subsection{روش‌های پرداخت سرویس {\normalsize \lr{Apple Pay}} }
	این سرویس برای پرداخت سه راه را به کاربران ارائه می‌دهد.
	\begin{itemize}
		\item[-] پرداخت درون فروشگاه 
		‌\item[-] پرداخت درون نرم‌افزار
		\item[-]پرداخت درون وب‌سایت
	\end{itemize}

	\subsection{مراحل کار با سرویس {\normalsize \lr{Apple Pay}} }
	برای استفاده از این سرویس در ابتدا باید کارت بانکی را که به منظور انجام خرید‌ها استفاده می‌شود، تعریف شود. لازم به ذکر است که کارت مورد نظر باید جزء کارت‌های پشتیبانی شده توسط
									{\normalsize \lr{Apple Pay}} 
									 باشد. در شکل \ref{applepayenvironment} محیط نرم‌افزار برای اضافه کردن نشان داده شده است. 
									 
									 
	\begin{figure}[h]
		\centering
		\includegraphics[height=7cm]{images/iphone6-ios9-wallet-applepay-add}
		\caption{محیط نرم‌افزار  {\footnotesize \lr{Apple Pay}}  }
		\label{applepayenvironment}
	\end{figure}
با کلیک نمودن بر روی آیکون «+ي ‌در بالای صفحه، وارد مراحل اضافه کردن کارت بانکی خواهید شد.  پس از احراز هویت و تایید آن توسط بانک،
								{\normalsize \lr{Apple Pay}}  
								برای انجام خرید‌ها آماده است. 
								
								در ادامه مراحل پرداخت برای سه روش ارائه شده توضیح داده خواهد شد. پرداخت‌های فوق هم از طریق گوشی‌های هوشمند 
																{\normalsize \lr{iPhone }} 
																و هم از طریق 
															{\normalsize \lr{Apple Watch}} 
																								امکان‌پذیر است. 
											
								
	\subsubsection{پرداخت درون فروشگاه} 
	کاربر پس از اتمام خرید در فروشگاه، می‌تواند از این روش پرداخت برای تکمیل خرید خود اقدام کند. پس از  ارائه‌ی صورت حساب توسط صندوق دار، کاربر گوشی و یا 
														{\normalsize \lr{Apple Watch}} 
	 خود را نزدیک به میدان 
									{\normalsize \lr{NFC}}
 ترمینال می‌کند، و سپس اجازه‌ی پرداخت را با استفاده از اثر انگشت خود و یا کلمه‌ی عبور می‌دهد.
 		بر روی  									{\normalsize \lr{Apple Watch}}									 									 									کاربر لبه‌ی انتهایی آن را دو بار لمس می‌کند.
 ترمینال‌های مجاز برای استفاده از این روش پرداخت دارای نشان شکل     
 \ref{applepaysymbol}
می‌باشند.
 \begin{figure}[h]
 	\centering
 	\includegraphics[height=2cm]{images/applepaysymbol}
 	\caption{نماد 	{\footnotesize \lr{NFC Apple Pay}}}
 	\label{applepaysymbol}
 \end{figure}

 ترمینال‌های مورد پشتیبانی همانند شکل 
 \ref{apple-pay-whole-foods}
 می‌باشند، که دارای نماد 
 									{\normalsize \lr{Apple Pay}}
 									هستند.
	\begin{figure}[h]
		\centering
		\includegraphics[height=5cm]{images/apple-pay-whole-foods-100526329-large}
		\caption{ترمینال پشتیبانی کننده از {\footnotesize \lr{Apple Pay}}}
		\label{apple-pay-whole-foods}
	\end{figure}
	
	\subsubsection{ پرداخت درون نرم‌افزار   }
	کاربر با استفاده از 
		 									{\normalsize \lr{iPhone}}،
		 									 									{\normalsize \lr{Watch}} و
		 	 									{\normalsize \lr{iPad}} ،
		 	 									می‌تواند از 
		 	 									 									{\normalsize \lr{Apple Pay}}
		 	 									 									به عنوان روش پرداخت برای پرداخت‌های درون نرم‌افزار استفاده کند. برای انجام پرداخت از این راه مراحل زیر لازم است:
	\begin{enumerate}
		\item لمس دکمه
			 									{\normalsize \lr{Apple Pay}}
			 									  و یا لمس
			 									{\normalsize \lr{Buy with Apple Pay}}.
			 									یا انتخاب
			 									 									{\normalsize \lr{Apple Pay}}
به عنوان روش پرداخت در زمان بازبینی نهایی خرید (شکل \ref{buttons}).
\begin{figure}[h]
	\centering
	\includegraphics[height=2cm]{images/buttons}
	\caption{آیکون‌های {\footnotesize \lr{Apple Pay}} ‌}
	\label{buttons}
\end{figure}


	\item بازبینی اطلاعات صورت حساب، اطلاعات تماس و نحوه‌ی ارسال خرید، برای حصول اطمینان از صحت اطلاعات.
	اگر کاربر مایل به پرداخت با کارت متفاوتی غیر از کارت پیش فرض ‌باشد،   باید علامت فلش لمس شود.
	\item اگر نیاز به وارد کردن اطلاعات تماس، صورت حساب و یا نحوه‌ی ارسال محموله ‌باشد، کاربر اطلاعات را وارد می‌کند.
	 									{\normalsize \lr{Apple Pay}} 
	 									این اطلاعات را ذخیره می‌کند تا نیازی به وارد کردن دوباره‌ی آن‌ها نباشد.
	\item بر روی 
	 									{\normalsize \lr{iPhone}}
	 									و 
	 									 {\normalsize \lr{iPad}}
	 								کاربر با استفاده از اثر انگشت اجازه‌ی پرداخت را می‌دهد.
	 								بر روی  									{\normalsize \lr{Apple Watch}}									 									 									کاربر لبه‌ی انتهایی آن را دو بار لمس می‌کند.
	\end{enumerate}
		
		
	\subsubsection{ پرداخت درون  وب سایت}
	اپل پشتیبانی از پرداخت درون وب‌سایت خود را به تازگی در پاییز ۲۰۱۵ به همراه مک ‌بوک جدیدش معرفی کرد. پرداخت از این راه فقط از طریق مرورگر 
		 									 {\normalsize \lr{Safari}}
		 									 قابل انجام است. مراحل انجام پرداخت همانند پرداخت درون نرم‌افزار می‌باشد. به جز اینکه در مک‌بوک جدید اپل قابلیت خواندن اثر انگشت اضافه شده. در مک‌بوک‌های سری قبل کاربر مجبور به اتصال گوشی و مک از راه بلوتوث، و انجام پرداخت از راه گوشی بود.
		 									 
	\section{‌‌نرم‌افزار‌های برجسته‌ی پرداخت موبایل }		
		بانک‌ها در سراسر جهان در حال عرضه‌ی پلتفورم‌های جدید بوده و شرکت‌های فعال دراین حوزه در حال انتشار در بازار‌های کشورها هستند. مصرف کنندگان نیز اشتیاق استفاده از این محصولات را نشان داده‌اند. 
	به نقل از 
			 									 {\normalsize \lr{Juniper Research}}،   پیش بینی‌شده است که پرداخت‌های صورت گرفته از راه موبایل و پرداخت بدون‌تماس در طی سال ۲۰۱۶  بالغ بر ۳.۶ تریلیون دلار خواهد بود.بنابراین آینده‌ی پرداخت موبایل بسیار امید‌بخش و خوب بنظر می‌آید
	\cite{juniperresearch}.
			 									 
			 									 با چنین انتظار بالایی، در ادامه  لیستی از نرم‌افزار‌های ابداعی پرداخت موبایل در بازار کنونی  آورده شده است. بعلاوه  ویژگی برجسته‌ی هر نرم‌افزار که آن‌را از بقیه‌ی نرم‌افزار‌ها متمایز کرده است،  بیان شده است.
	\subsection{ {\small \lr{Starbucks}}}
		 			 									 ویژگی: طرح‌های وفاداری، سرویس پرداخت از پیش
	
	 			 				 {\normalsize \lr{Starbucks}}	 			 									 
	 	 همیشه نسبت به رقبا در این عرصه برتری داشته است. از سال ۲۰۰۱ جزء اولین‌ها در ارائه‌ی {\normalsize \lr{WiFi}} درون فروشگاه بود و از سال ۲۰۰۹ جزء اولین پذیرندگان پرداخت موبایل بوده است. شمار تراکنش‌های موبایلی در فروش فروشگاه‌ها ۲۵ درصد کل ترانکش‌ها می‌باشد که با استفاده از آسان تر کردن راه‌های پرداخت برای مصرف کنندگان و ارائه‌ی سرویس سفارش از قبل، پرداخت‌ها و دریافت طرح‌های وفاداری و جایزه را آسان‌تر کرده است. 
	 	 			 									 
		\subsection{ {\small \lr{Royal Bank of Canada (RBC)}}}
		ویژگی: کارت‌های هدیه، رسید‌های دیجیتالی
		
		بزرگ‌ترین  صادرکننده‌ی کارت
				\LTRfootnote{card issuer}
		 کانادا با ۶.۵ میلیون کارت بانکی، بانک شناخته شده‌ی پیشتاز در عرصه‌ی پرداخت می‌باشد. نرم‌افزار این بانک بر پایه‌ی تکنولوژی 			
	 {\normalsize \lr{HCE}} 	\LTRfootnote{Host Card Emulation} 
	 می‌باشد، بدین معنی که کاربر نیازی ندارد حتما سیم‌کارت خاصی را داشته باشد(در فصل 
	 \ref{tokenisation}
	 در مورد تکنولوژی 
	 {\normalsize \lr{HCE}} 
	 صحبت خواهد شد و ضعف و قوت‌های این تکنولوژی بیان خواهد شد
	 ).
	
	\begin{figure}[h]
		\centering
		\includegraphics[height=5cm]{images/RBC}
		\caption{نرم‌افزار موبایل 	{\normalsize \lr{RBC}}}
		\label{fig:rbc}
	\end{figure}
در این نرم‌افزار کاربر می‌تواند کارت‌‌های اعتباری 
				\LTRfootnote{credit card}
و کارت بدهی 
						\LTRfootnote{debit card}
		را در کیف‌پول ذخیره کند و با استفاده از آن پرداخت درون فروشگاه انجام دهد،  می‌تواند کارت‌های جایزه را نیز به کیف‌پول خود اضافه کند و یا کارت‌های جایزه‌ی جدید را از طرح‌های وفاداری مختلف بخرد و اضافه کند، و آن‌ها را به دوستان خود ارسال کند.
		
		\subsection{{\small \lr{ANZ‌ Bank}}}
		%\Large
		ویژگی: انتخاب روش پرداخت
		
		بانک 
			 {\normalsize \lr{ANZ} }
			 	استرالیا اخیرا در زمینه‌ی پرداخت بدون تماس 
			 							\LTRfootnote{Contactless Payment}
			 	خبرساز بود. نرم‌افزار این بانک روش‌های مختلفی  برای اینکه کاربر چگونه فرآیند پرداخت خود را بر روی دستگاه خود آغاز کند، ارائه می‌دهد. 
 نرم‌افزار اجازه‌ی انتخاب نحوه‌ی فعال سازی پرداخت را به کاربر می‌دهد. بدین شکل که کاربر به منظور انجام پرداخت، تلفن‌همراه را بدون نیاز به باز کردن قفل آن فقط روشن کند و یا قبل از انجام پرداخت، کاربر نرم‌افزار بانک
 			 {\normalsize \lr{ANZ} }
 			 را اجرا کند، و یا کاربر نرم‌افزار 
 			 			 {\normalsize \lr{ANZ} }
 			 			 را باز کرده و یک کلمه‌ی عبور از قبل تعیین شده را به منظور انجام پرداخت وارد کند.
			 	بدین ترتیب نرم‌افزار به کاربر اجازه می‌دهد
			 	که روشی را که برایش راحت‌تر است، انتخاب کند.
			 	در شکل 
			 	\ref{fig:anz-bank-select-how-to-pay}
محیط نرم‌افزار بانک
			 {\normalsize \lr{ANZ} }
نشان داده‌شده است. 
			 	\begin{figure}[h]
			 		\centering
			 		\includegraphics[width=4cm]{images/ANZ-Bank-Select-how-to-Pay}
			 		\caption{نرم‌افزار بانک 	{\footnotesize \lr{ANZ}} }
			 		\label{fig:anz-bank-select-how-to-pay}
			 	\end{figure}
			 			
		\subsection{{\small \lr{CaixaBank}}}
		ویژگی: پرداخت با ابزار‌های پوشیدنی
		
			 {\normalsize \lr{CaixaBank}} 
			 صاحب شهرت در عرصه‌ی پرداخت موبایل،  و بازار بزرگی از پرداخت‌های بدون تماس در کشور اسپانیا می‌باشد. در سال ۲۰۱۵ پرداخت موبایل بر پایه‌ی تکنولوژی 
			  	 			 				 {\normalsize \lr{HCE}}
خود را ارائه کرد، و در سال ۲۰۱۶ {\normalsize\lr{ImaginBank}}را معرفی کرد،  که با استفاده از نرم‌افزار 
			 			 				 {\normalsize \lr{ImaginPay}}	
			 			 				 با بهره‌گیری از تکنولوژی‌
			 			 			 {\normalsize\lr{NFC}}	 	
			 			 			 و گوشی‌های هوشمند و ابزار‌های پوشیدنی،   کاربر اقدام به پرداخت می‌کند. ابزار‌های نرم‌افزار 
			 			 			 			 {\normalsize \lr{CaxiaBank} }
			 			 			 			 در شکل 
			 			 			 			 \ref{fig:caixabank-pay-with-wearables-768x432}
			 			 		نشان‌ داده‌ شده‌اند. 
			 			 			 
			 			 			 \begin{figure}[h]
			 			 			 	\centering
			 			 			 	\includegraphics[height=4cm]{images/CaixaBank-pay-with-wearables-768x432}
			 			 			 	\caption{ابزار‌های نرم‌افزار بانک {\footnotesize \lr{CaixaBank}}}
			 			 			 	\label{fig:caixabank-pay-with-wearables-768x432}
			 			 			 \end{figure}
			 			 			 				 			 			 		
	\newpage		 			 			 		
		\subsection{{\small \lr{Capital One}}} 			 									 
		ویژگی: امنیت با استفاده از تکنولوژی 
					 			 				 {\normalsize \lr{Tokenisation}}	
 
 
 اواخر سال میلادی ۲۰۱۵ اولین بانک آمریکایی بود که پرداخت از طریق 
 			 			 				 {\normalsize \lr{NFC}}	
 			 			 				 درون نرم‌افزار‌های موبایلش را عرضه کرد. مورد قابل توجه تر این است که این نرم‌افزار از تکنولوژی 
 			 			 				 			 			 				 {\normalsize \lr{Tokenisation}}
 			 			 				 			 			 				 به عنوان مکانیزم امنیتی خود استفاده کرده است تا از اطلاعات کارتی و حساس کاربران استفاده‌ای نشوند و امن بمانند. در شکل 
 	\ref{fig:capital-one-tokenization-768x384}
 	محیط نرم‌افزار 
 				 {\normalsize \lr{Capital One} }
 				نشان داده شده است.		 			 				 			 			 				 
 			 			 				 			 			 				 
 			 			 				 			 			 				 
 \begin{figure}[h]
 	\centering
 	\includegraphics[height=5cm]{images/Capital-One-Tokenization-768x384}
 	\caption{نرم‌افزار بانک {\footnotesize \lr{Capital One}}}
 	\label{fig:capital-one-tokenization-768x384}
 \end{figure}

 			\subsection{{\small \lr{SnapScan}}}
 			ویژگی: استفاده از تکنولوژی 
 			 			 			 				 {\normalsize \lr{Beacon}}	
 			 			 			 			\newline
  			 			 			 				 {\normalsize \lr{SnapScan}}
  			 			 			 				 بیش از ۳۰۰۰۰ پذیرنده \LTRfootnote{Merchant}
  			 			 			 				  را تحت پشتیبانی خود دارد و با تمامی بانک‌های آفریقای جنوبی همکاری می‌کند. این نرم‌افزار  در زمان انجام پرداخت  از بارکد‌های دو بعدی 
  			 				\LTRfootnote{QR-code}			 			 				 
برای پیدا کردن فروشگاهی که کاربر در آن حاضر است، استفاده می‌کند. اما به تازگی قابلیتی به نام 
 			 			 			 				 {\normalsize\lr{SnpanBeacons}} اضافه کرده است . 
 			 			 			 				 با استفاده از این قابلیت مکان کاربر بدون استفاده از هیچ‌گونه اسکن و فقط با حضور کاربر در فروشگاه مشخص می‌شود. در فصل \ref{clientimplementation} به معرفی این تکنولوژی و طرز کار آن به طور کامل پرداخته خواهد شد.
 	
	  \section{   سرویس    {\normalsize \lr{Amazon Go}}  }
 		{\normalsize \lr{Amazon Go}} 		
 	نوع جدیدی از فروشگاه  بدون نیاز به چک‌نهایی
 	\LTRfootnote{checkout}است.
شرکت 
 		{\normalsize \lr{Amazon}} پیشرفته‌ترین نوع پرداخت در جهان را بوجود آورده به این شکل که نیازی به ماندن در صف برای انجام پرداخت وجود ندارد. 
 	
 	به گفته‌ی آمازون	عرضه‌ی کامل این سرویس اوایل سال ۲۰۱۷ خواهد بود. 
 		
 		طرز استفاده از این سرویس به این شکل خواهد بود که کاربر از نرم‌افزار 
 		 		{\normalsize \lr{Amazon Go}} 		
 برای ورود به فروشگاه استفاده می‌کند،  سپس خرید خود را در فروشگاه انجام می‌دهد و با خروج از فروشگاه چندی بعد آمازون رسید پرداخت را به کاربر می‌دهد.

آمازون	از تکنولوژی‌هایی که در ماشین‌های خودران
\LTRfootnote{self-driving car}
 استفاده می‌شود بهره می‌برد :{\normalsize \lr{computer vision}}،
 					 				{\normalsize \lr{deep learning}}،
 					 					{\normalsize \lr{sensor fusion}}
 					 					 
 \noindent
 آمازون اسم این تکنولوژی را 
 	{\normalsize \lr{Just Walk Out}}
 	گذاشته است
 	\cite{amazongo}.
 			 			 		
 			 			 			 				 			 			 	 
  	\section{معرفی نرم‌‌افزار پیاده‌سازی شده}
   در این بخش به معرفی مختصر نحوه‌ی کار و قسمت‌های مختلف نرم‌افزار پیاده‌سازی شده  پرداخته می‌شود. 
   
   		   \subsection{تکنولوژی‌های استفاده شده}
   		 این نرم‌افزار  دارای دو بخش، سمت کلاینت و سمت سرور می‌باشد. نرم‌افزار سمت کلاینت بر روی پلتفورم 
   		 {\normalsize\lr{ios}}
   		 پیاده‌سازی شده است  و قابل استفاده و بر روی تلفن‌های همراه 
   		 {\normalsize\lr{iPhone}}
   		 می‌باشد. در این نرم‌افزار برای پیدا کردن موقعیت فعلی کاربر از تکنولوژی 
   		 {\normalsize\lr{iBeacon}}
   		و برای اضافه کردن کالا‌ها به لیست خرید از بارکد‌های دوبعدی استفاده شده است. 
   		 
   		  نرم‌افزار سمت سرور متشکل‌ از وب‌سرویس‌ها می‌باشد که از پلتفورم جاوا بهره می‌برند.  
   		  برای پیاده‌سازی وب‌سرویس‌ها ،
   		     		 {\normalsize\lr{Servlet Framework}}
   		     		 و برای ارتباط با پایگاه‌داده  
   		     		    		 {\normalsize\lr{Hibernate Framework}}
   		     		    		 مورد استفاده قرار گرفته است.
   		  همچنین برای تایید شماره‌ی تلفن همراه کاربر،  از  سرویس پیام‌کوتاه استفاده شده است.
   		  
		   \subsection{نحوه‌ی کار نرم‌افزار}

مراحل کار با نرم‌افزار به شکل زیر می‌باشد:
\begin{enumerate}
	\item در صورت اینکه کاربر از قبل دارای حساب کاربری باشد کاربر تنها اقدام به ورود می‌کند،
	  			 				\LTRfootnote{sign-in}		 
	در غیر این صورت اقدام به ثبت نام می‌کند.  
	
	\begin{figure}[h!]
		\begin{center}
			
		\subfigure[صفحه‌ی ورود]{
					
			\includegraphics[width=6cm]{appphotos/1}
				\label{fig:1}	
	}
		\subfigure[صحفه‌ی ثبت‌نام]{
			
				\includegraphics[width=6cm]{appphotos/2}
		\label{fig:2}
	}
		\caption{صفحات ورود و ثبت نام }
\end{center}
	\end{figure}
	
	بعد از ثبت‌نام کاربر پیامکی حاوی یک کد چهار رقمی مبنی   بر تایید شماره‌ی تلفن دریافت کرده و سپس آن‌را وارد می‌کند.
	
	شکل 
	\ref{fig:1}
	نشان دهنده‌ی صفحه‌ی ورود و شکل 
	\ref{fig:2}
	نشان دهنده‌ي صفحه‌ی ثبت نام کاربر می‌باشد.
	
\newpage

	\item قبل از انجام خرید کاربر به منظور تکمیل فرآیند خرید نیازمند به فراهم کردن اطلاعات کارت بانکی می‌باشد. با لمس کردن اضافه کردن کارت کاربر وارد صفحات اضافه کردن کارت بانکی می‌شود و این عملیات را به انجام می‌رساند.
	شکل 
	\ref{fig:3}
	نشان دهنده‌ی صفحه‌ی لیست کارت‌ها و شکل
	\ref{fig:4}
	نشان دهنده‌ی صفحه‌ی اضافه کردن کارت‌ها می‌باشد.
	\begin{figure}[h!]
	\begin{center}
		\subfigure[لیست کارت‌ها]{
		\includegraphics[width=6cm]{appphotos/3}
		\label{fig:3}
		}
		\subfigure[اضافه کردن کارت‌ها]{
		\includegraphics[width=6cm]{appphotos/4}
		\label{fig:4}
		}
		\caption{صفحات مدیریت کارت‌ها}
	\end{center}
\end{figure}

\newpage

	\item با حضور کاربر در فروشگاه‌های تحت پشتیبانی،  نرم‌افزار،   مکان فعلی کاربر را تشخیص داده و یک اعلانی به کار بر نشان می‌دهد. با باز کردن نرم‌افزار کاربر می‌تواند اقدام به خرید ‌کند. 
شکل 
\ref{fig:6}
نشان‌ دهنده‌ی اعلان نشان داده به کاربر می‌باشد. 
\begin{figure}[h!]
	\centering
	\includegraphics[width=6cm]{appphotos/6}
	\caption{اعلان نشان داده شده}
	\label{fig:6}
\end{figure}
	در صورتی که فروشگاه تحت پشتیبانی در نزدیکی کاربر نباشد امکان انجام خرید نخواهد بود. شکل ۱۳.۱ نشان دهنده‌ی وضعیتی است که کاربر در فروشگاهی حضور ندارد. 
		\begin{figure}[h!]
		\begin{center}
			\subfigure[صحفه‌ی اسکن]{
				\includegraphics[width=7.5cm]{appphotos/8}
				\label{fig:8}
			}
			\subfigure[لیست خرید]{
				\includegraphics[width=7.5cm]{appphotos/5}
				\label{fig:5}
			}
			\caption{وضعیت نرم‌افزار زمانی که کاربر در فروشگاه حضور ندارد}
		\end{center}
\label{fig:58}
	\end{figure}	
	
	\newpage
	
	\item با تشخیص مکان کاربر توسط نرم‌افزار، مکان حاضر به کاربر اعلان می‌شود و  امکان اسکن کردن کد‌های کالاها فراهم می‌شود،   بدین منظور کاربر با استفاده از دوربین تلفن همراه کد
	   		     		 {\normalsize\lr{QR}}
	  			 				 را اسکن می‌کند. شکل 
	  			 				 \ref{fig:7}
	  			 				 نشان دهنده‌ی تشخیص حضور کاربر در فروشگاه می‌باشد.	 				 
	 \begin{figure}[h]
	 	\centering
	 	\includegraphics[width=8cm]{appphotos/7}
	 	\caption{تشخیص حضور کاربر در فروشگاه}
	 	\label{fig:7}
	 \end{figure}
	  			 				 		 				
	\newpage  			 				
	  			 				
	\item پس از اسکن بارکد دوبعدی اطلاعات کالا بعلاوه‌ی مبلغ کالا به کاربر نمایش داده می‌شود.
شکل 
\ref{fig:9}
اطلاعات نمایش داده شده برای کالا را نشان می‌دهد.
	
	\item کاربر اضافه به لیست خرید را لمس می‌کند و کالا به لیست خرید اضافه می‌شود.
شکل 
\ref{fig:10}
لیست خرید بعد از اضافه کردن کالا را نمایش می‌دهد. 
	
	
	\newpage
	
		\begin{figure}[h!]
		\begin{center}
			\subfigure[اطلاعات کالا]{
				\includegraphics[width=6cm]{appphotos/9}
				\label{fig:9}
			}
			\subfigure[لیست خریدها]{
				\includegraphics[width=6cm]{appphotos/10}
				\label{fig:10}
			}
			\caption{صفحات پس از اسکن کردن بارکد}
		\end{center}
	\end{figure}

\newpage

	\item در صفحه‌ی لیست کالاها، کاربر پرداخت در اینجا را می‌زند و وارد مراحل پرداخت می‌شود.
\end{enumerate}
		   
		%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		
		\chapter{تکنولوژی {\Large\lr{Tokenisation}} و زیرساخت‌ها }\label{tokenisation}
	در این فصل به بررسی تکنولوژی‌ها و زیرساخت‌های  مورد نیاز در پرداخت‌های امروزی همچون 
	   		 {\normalsize\lr{Tokenisation}} , 
	    		 {\normalsize\lr{Host Card Emulation}} , 
	    		    		 {\normalsize\lr{Secure Element}} 
	پرداخته خواهد شد.
	
	\noindent

		
	\section{تعاریف اولیه}\label{definitions}
			در ابتدا نیاز به بیان تعاریف اولیه‌ در زمینه‌ی بانکی می‌باشد، که در این بخش به تعریف این مفاهیم خواهیم پرداخت. 
\subsection{بانک صادر کننده}			
		بانک صادر کننده\LTRfootnote{Issuer Bank}،   بانكي است كه كارت بانكي را طبق مقررات و ضوابط بانك مركزی برای مشتريان خود صادر
می‌كند.
\subsection{پذیرنده}
پذیرنده \LTRfootnote{Merchant}،   شخص حقيقي يا حقوقي است كه با پذيرش كارت بانكي و با استفاده از ابزار پذيرش نسبت به
فروش كالا و يا ارايه خدمات به دارندگان كارت اقدام مي‌نمايد.  			 				
	  			 				
\subsection{بانک پذیرنده}
بانک پذیرنده 
	  			 				\LTRfootnote{Acquirer Bank}			 
	، بانكي است كه حساب پذيرنده به منظور واريز وجوه مربوط به داد و ستدهای كارت‌های‌		بانكي نزد آن مفتوح است. 
		
\subsection{دارنده‌ی کارت}		
		دارنده‌ی کارت 
	  			 				\LTRfootnote{Card Holder}
	  			 				،شخص حقيقي است كه كارت بانكي توسط بانك به نام وي صادر شده باشد.			 		
\subsection{خدمات پرداخت}
خدمات پرداخت 		
			  			 				\LTRfootnote{Payment Services}
			  			 				، عبارتند از فراهم ساختن سختافزار، نرم‌افزار و تجهيزات مورد لزوم و ايجاد شبكه به نحوي كه
پردازش تراكنش پرداخت دارنده كارت به پذيرنده را ميسر سازد. 
\subsection{ابزار پرداخت}
به هرگونه وسيله‌اي اطلاق ميگردد كه دارنده آن مي‌تواند نسبت به انتقال وجوه از طريق آن اقدام
نمايد. 
\subsection{کارت بانکی}
کارت بانکی
			  			 				\LTRfootnote{Bank Card}
نوعي ابزار پرداخت است كه بانک براساس مقررات برای مشتريان خود صادر مي‌كند
\cite{centralbank}.

\subsection{شماره‌ی کارت   ({\normalsize \lr{‌PAN}}) }
شماره‌ی کارت بانکی و یا 
					{\normalsize \lr{PAN}}
			\LTRfootnote{Primary Account Number} ، 
			یک کد ۱۳ تا ۱۹ رقمی  مطابق با استاندارد {\normalsize \lr{ISO 7812}}،
			است.
					این شماره توسط بانک صادر‌کننده تولید می‌شود و بر روی کارت‌های بانکی منقّش می‌شود. 

\subsection{شبکه‌ی پرداخت}
شبکه‌ی پرداخت 
			  			 				\LTRfootnote{Peyment Network}، 
			  			 				یک سیستم الکترونیکی به منظور پذیرش، انتقال و یا پردازش تراکنش‌های ایجاد شده توسط کارت‌های پرداخت برای، کالاها و خدمات وغیره است. این سیستم به منظور انتقال اطلاعات و وجوه در میان بانک‌های پذیرنده ، پردازنده‌های پرداخت ، پذیرنده‌ها و دارندگان کارت می‌باشد. 

\subsection{پردازنده‌ی پرداخت}			  			 							  			 				
پردازنده‌ی پرداخت 
			 	\LTRfootnote{Peyment Processor}، 
یک موجودیت به منظور فراهم کردن خدمات پردازش پرداخت‌ها برای بانک‌های پذیرنده و یا صادر‌کننده می‌باشد. 
		
\section{ تاریخچه تکنولوژی     {\large  \lr {Tokenisation}}}
					در ماه مارس سال ۲۰۱۴ کنسرسیوم 
					{\normalsize \lr{EMV}} 
					\LTRfootnote{Europay MasterCard Visa consortium (EMVco)}
					مشخصات فنی تکنولوژی 
					را معرفی کرد. به دنبال آن شرکت‌های فعال در این زمینه با بهره‌وری از این تکنولوژی سرویس‌های کیف‌پول الکترونیکی خود را معرفی کردند.

\section{ مقدمه‌ای بر تکنولوژی     {\large  \lr {Tokenisation}} }					
ذینفعان تکنولوژی 
{\normalsize  \lr {Tokenisation}}			
عبارت‌اند از:‌ بانک‌های پذیرنده،  پذیرنده‌ها، بانک‌های صادرکننده،  و دارندگان کارت بانکی که از این تکنولوژی بهره می‌برند. 

مسائلی همچون درخواست
{\normalsize  \lr {Token}}،   صدور و فراهم کردن
{\normalsize  \lr {Token}}
و پردازش تراکنش‌ها از مسائل مهم در زمینه‌ی 
{\normalsize  \lr {Tok‌enisation}}
می‌باشد. همچنین تعریف مواردی مانند،  مسئولیت‌های کلیدی،   تعریف اکوسیستم موجود، اصطلاحات فنی و تعریف هر موجودیت در اکوسیستم ضروری می‌باشد.  در بخش 
\ref{definitions}
قسمتی از تعاریف مورد نیاز آورده شد. 

\subsection{خلاصه‌ی کلی}
صنعت پرداخت در حال تحول و فراهم آوردن فاکتورهای جدید به منظور مقابله با کلاه‌برداری‌ها در زمینه‌ی پرداخت همچون،
					{\normalsize \lr{counterfeit}} ، 
							{\normalsize \lr{account misuse}}
	و دیگر فرم‌های کلاه‌برداری در این زمینه می‌باشد.  در حالی که تراشه‌های 
						{\normalsize \lr{EMV}}
بر روی کارت‌های بانکی ، محافظت قابل توجهی را برای تراکنش‌هایی که کارت بانکی در آن‌ها حضور دارند فراهم می‌آورد، نیاز مشابهی نیز به منظور کمینه کردن دسترسی‌های غیر مجاز به داده‌های حساب دارنده‌ی کارت برای تراکنش‌هایی که کارت بانکی در آن‌ها حضور فیزیکی ندارند وجود دارد.  سیستم‌های پرداخت مبتنی بر
					{\normalsize \lr{PAN}}
پاسخگوی این نیازها می‌باشد.

{\normalsize  \lr {Token}} های 
پرداخت،  مقادیری جایگزین برای مقدار واقعی 
{\normalsize  \lr {PAN}}ها 
در اکوسیستم پرداخت می‌باشند. به این فرآیند 
{\normalsize \lr{‌Tokenisation}}
 گفته می‌شود. در این فصل به چگونگی ساخت و ملزومات ساخت این 
{\normalsize  \lr {Token}}ها
خواهیم پرداخت. 

{\normalsize  \lr {Token}}های پرداخت
ممکن است توسط تمامی متدهای احرازهویت دارنده‌ی کارت 
(
{\normalsize  \lr {CVM}}
\LTRfootnote{Cardholder Verification Method})
استفاده شوند ، از جمله استفاده این روش‌ها، می‌توان به امضای دیجیتالی ، پین‌های آنلاین و آفلاین ، و بدون
{\normalsize  \lr {CVM}}
اشاره نمود.
														
 به علاوه در زمان صدور 
 {\normalsize  \lr {Token}}
 پرداخت، مراحلی به منظور احراز هویت دارنده‌ی کارت و اطمینان حاصل کردن از صحت و اعتبار 
 {\normalsize  \lr {PAN}}
 لازم می‌باشد.
 این فرآیند به عنوان  شناسایی و تشخیص صحت 
({\normalsize  \lr {ID\&V}})
	\LTRfootnote{Identification and Verification}
شناخته می‌شود و هر بار که درخواست 
{\normalsize  \lr {Token}}
پرداخت داده می‌گیرد. انواع مختلف 
{\normalsize  \lr {ID\&V}}
می‌تواند اعمال شود ، که در نتیجه‌ی آن بر روی پارامتر سطح اطمینان 
{\normalsize  \lr {Token}}
	\LTRfootnote{Token Assurance}
تأثیر دارد. برای مثال اگر با مقدار کمینه و یا بدون 
{\normalsize  \lr {ID\&V}}
مورد استفاده قرار گیرد، منجر به سطح پایینی از اطمینان 
{\normalsize  \lr {Token}}
پرداخت خواهد شد،  و همینطور بالعکس. 

فواید زیادی برای ذینفعانی که از این اکوسیستم پرداخت استفاده می‌کنند وجود دارد که کمک به تشویق آن‌ها برای اقتباس این تکنولوژی می‌کند:
\begin{itemize}
	\item[-] 
	صادرکنندگان کارت و دارندگان کارت بانکی می‌توانند از راه‌های جدید و امن برای پرداخت استفاده کنند، و اگر اطلاعات آن‌ها با استفاده از کلاهبرداری‌ها فاش شود، اطلاعات به درد نخوری مثل 
	{\normalsize  \lr {Token}}
	به جای اطلاعات حساس مثل 
	{\normalsize  \lr {PAN}}
	فاش می‌شود. 
	\item[-]
	بانک‌های پذیرنده و پذیرنده‌ها، تجربه‌ی کمتری در برابر تحدیدهای آنلاین و از دست‌دادن داده‌ها خواهند داشت.
	\item[-] 
	شبکه‌های پردازش پرداخت قادر خواهند بود که یک دستورالعمل و مشخصات باز را اقتباس کنند. این موضوع به  بهبود قابلیت همکاری کمک می‌کند و باعث کاهش ملزومات محافظت از داده برای شبکه‌ی پرداخت و شرکای آن‌ها می‌شود. 
\end{itemize}

\section{اکوسیستم {\large  \lr {Tokenisation}}}					
پیاده‌سازی راه‌حل‌های 
{\large  \lr {Token}}
پرداخت مستلزم وجود نقش‌هایی درون این اکوسیستم می‌باشد. بعضی از این نقش‌ها در صنعت پرداخت سنتی حاضر موجود هستند، و برخی دیگر نقش‌های جدیدی هستند که در این اکوسیستم تعریف می‌شوند. 

در دیاگرام‌های شکل 
\ref{fig:fig1}
و 
\ref{fig:fig2}
 نقش‌های مختلف در این اکوسیستم  بصورت خلاصه آورده شده است. نقش‌های موجود در بخش‌های پیش رو توضیح داده می‌شوند.

\begin{figure}
	\centering
	\includegraphics[height=20cm]{images/fig1}
	\caption{فراهم‌کردن{\footnotesize  \lr {Token}} پرداخت }
	\label{fig:fig1}
\end{figure}

\begin{figure}
	\centering
	\includegraphics[height=20cm]{images/fig2}
	\caption{تراکنش {\footnotesize  \lr {Token}} پرداخت}
	\label{fig:fig2}
\end{figure}
\newpage
\subsection{{\normalsize \lr{Token Service Provider}}}
		{\normalsize  \lr {Token Service Provider (TPS)}}ها 
		موجودیت‌های درون اکوسیستم
		{\normalsize  \lr {Tokenisation}}
		هستند که موظف به فراهم کردن 
		{\normalsize  \lr {Token}}های
		پرداخت به درخواست‌دهنده‌های 
		{\normalsize  \lr {Token}}
		ثبت شده هستند. 
 
 \subsubsection{{\small \lr{‌Token Vault}}}
			یک انبار برای نگهداری 
			{\normalsize \lr{‌Token}}های
			پرداخت که توسط اکوسیستم 
			{\normalsize \lr{‌Tokenisation}}
			پیاده‌سازی شده است. از این انبار اطلاعات برای مرتبط کردن 
			{\normalsize \lr{‌Token}}‌های 
			مربوطه به مقادیر 
			{\normalsize \lr{‌PAN}}
			نیز استفاده می‌شود. 
			{\normalsize \lr{‌Token Vault}}
			ممکن است مقادیر دیگری از درخواست دهنده‌ی 
			{\normalsize \lr{‌Token}}
			که در زمان ثبت تعیین می‌شود و ممکن است توسط 
			{\normalsize \lr{‌TSP}}
			به منظور اعمال محدودیت‌های دامنه‌ای و یا کنترل بر روی پردازش تراکنش‌ها انجام گیرد، را ذخیره کند.
					
	{\normalsize \lr{‌TSP}}ها 
	مسئول بخش‌‌های مختلفی در این اکوسیستم به عنوان  یک موجودیت تأیید شده برای صدور 
	{\normalsize \lr{‌Token}}های 
	پرداخت می‌باشند. برخی از این مسؤلیت‌ها شامل‌:
	\begin{itemize}
		\item[-]محافظت و اداره کردن 
				{\normalsize \lr{‌Token Vault}}	
		\item[-]تولید 
					{\normalsize \lr{‌Token}}
					پرداخت و انتشار آن
		\item[-] اختصاص و فراهم کردن 
					{\normalsize \lr{‌Token}}ها
		\item[-]وظایف مربوط به ثبت درخواست دهنده ‌های 
					{\normalsize \lr{‌Token}}
	\end{itemize}
								{\normalsize \lr{‌TSP}}ها 
								مسؤل ساخت و مدیریت، رابط‌های نرم‌افزاری درخواست دهنده، 
											{\normalsize \lr{‌Token Vault}}،
								 پلتفورم‌های اختصاص 
														{\normalsize \lr{‌Token}}،
														 و ثبت‌کننده‌های 
																	{\normalsize \lr{‌Token}}
																	می‌باشند. 

\subsubsection{درخواست دهنده‌ی     {\small \lr{‌Token}}}
درخواست دهنده ‌های 
{\normalsize \lr{‌Token}}
پرداخت می‌توانند شریک‌های سنتی در صنعت پرداخت و یا شریک‌های جدیدی باشند. برخی از درخواست دهنده‌های 
{\normalsize \lr{‌Token}}
عبارت‌اند از: 
\begin{itemize}
	\item[-] پذیرنده‌های کارت بر روی فایل
	 	\LTRfootnote{Card-on-file Merchants}
	\item[-]بانک‌های پذیرنده،  پردازنده‌های بانک‌های پذیرنده،  و دروازه‌هایی به جای پذیرنده
	\item[-]توانمندسازهای پرداخت مثل، 
	تولیدکننده‌های دستگاه
	{\normalsize \lr{‌original equipment manufacturer (OEM)}}
	\item[-]فراهم‌کننده‌های کیف‌پول الکترونیکی
	\item[-] بانک‌های صادرکننده 
\end{itemize}
درخواست‌دهنده‌های 
{\normalsize \lr{‌Token}}
نیاز به ثبت در 
{\normalsize \lr{‌TSP}}
خواهند داشت و با ملزومات ثبت،  سیستم‌ها و فرآیندها مطابقت داشته باشند. بعد از یک ثبت موفق توسط یک 
{\normalsize \lr{‌‌TSP}}
، به درخواست‌دهنده‌ی 
{\normalsize \lr{‌Token}}
یک شناسنده‌ی درخواست‌دهنده‌ی 
{\normalsize \lr{‌Token}}
اختصاص داده خواهد شد. 

موجودیت‌‌های دیگر در اکوسیستم 
			{\normalsize \lr{‌Tokenisation}}
همانند،   دارنده‌ی کارت،   صادرکننده، پذیرنده،   بانک پذیرنده و شبکه‌ی پرداخت، نقش اصلی خود را حفظ خواهند کرد و تغییر بسزایی نخواهند داشت. در خیلی از موارد دارندگان کارت متوجه تبدیلات  
{\normalsize \lr{‌Token}}
نخواهند شد و به روند عادی خود در استفاده از کارت بانکی خود ادامه می‌دهد.

در مواردی که پذیرنده‌ها به عنوان درخواست دهنده‌ی 
{\normalsize \lr{‌Token}}
نیز می‌باشند باید منطبق بر رابط نرم‌افزاری
{\normalsize \lr{TSP}}
مورد نظر این درخواست صورت بگیرد و خود را منطبق سازد.
\cite{emvframework}.

\section{{\large \lr{Secure Element}}}
یک 
{\normalsize \lr{Secure Element (SE)}}
، پلتفورمی سخت‌افزاری بسیار ایمن به منظور ذخیره‌ی نرم‌افزارها و داده‌های محرمانه و رمزگذاری شده است. بنابراین 
{\normalsize \lr{SE}}
نقش بسیار مهمی در زمینه‌ی محاسبات موبایلی 
	 	\LTRfootnote{Mobile Computing}
بازی می‌کند.

برای مثال، در صنعت مالی از 
{\normalsize \lr{SE}}
 به منظور ذخیره‌سازی نرم‌افزار‌های کارت و کلیدهای مخصوص رمزنگاری که ملزومات تراکنش‌های مالی
{\normalsize \lr{EMV}}
بوسیله‌ی 
{\normalsize \lr{POS}}
هستند، 
استفاده می‌شود. 
{\normalsize \lr{SE}} ها 
همچنین در بازار تعیین هویت مورد استفاده قرار می‌گیرد، که به منظور ذخیره‌سازی گواهینامه‌ها 
	 	\LTRfootnote{Certificate}
	 	و یا داده‌های بیومتریک 
	 		 	\LTRfootnote{Biometric data}
	 	می‌باشد. در شکل 
	\ref{fig:se}
	نمای کلی زیرساخت 
	{\normalsize  \lr {SE}}
	نشان داده شده است.

\begin{figure}[h]
	\centering
	\includegraphics[height=5cm]{images/se}
	\caption{{\footnotesize \lr{Secure Element}}}
	\label{fig:se}
\end{figure}



\section{{\large \lr{Host Card Emulation}}}
همانطور که در بخش قبل تشریح شد،
به صورت مرسوم  نرم‌افزارهای کیف‌پول الکترونیکی و
{\normalsize \lr{NFC}}
داده‌های مورد نیاز برای انجام یک تراکنش را بر روی یک تراشه‌ی فیزیکی به نام 
{\normalsize \lr{SE}}
درون یک سرویس موبایل،
ذخیره می‌کنند. به همین علت مالکان 
{\normalsize \lr{SE}}
همانند تولید کنندگان تلفن همراه و گردانندگان شبکه‌ی تلفن همراه
{\normalsize \lr{MNO}}
	 	\LTRfootnote{Mobile Network Operator}
	 	، اجازه‌ی دسترسی و استفاده از این تراشه‌ها  صادر می‌کنند و شارژهای مربوط به 
{\normalsize \lr{SE}}
را انجام می‌دهند.

همچنانکه چندین و چند گرداننده‌ی 
{\normalsize \lr{SE}}
در سراسر جهان وجود دارد، هر کدام دارای یک مدل تجاری و فنی هستند. ارائه دهندگان خدمات برای ارائه‌ی سرویس‌ها در قالب
{\normalsize \lr{NFC}}
ملزم به برقراری ارتباط با هریک از آن‌ها هستند. بسیاری از کارشناسان صنعت پرداخت مشکل یکی کردن سرویس‌ها و وجود چالش برای برقراری ارتباط با دارندگان
{\normalsize \lr{SE}} را
مشکلات اصلی در پیاده‌سازی کامل پرداخت 
{\normalsize \lr{NFC}}
می‌دانند. با بوجود آمدن تکنولوژی 
{\normalsize \lr{Host Card Emulation (HCE)}}
این صنعت دچار پیشرفت چشم‌گیری شد. این تکنولوژی به تراکنش‌های بر اساس 
{\normalsize \lr{NFC}}
اجازه می‌دهد تا بدون نیاز به حضور 
{\normalsize \lr{SE}}
و اتصال به آن، انجام شوند. بدین وسیله تکنولوژی 
{\normalsize \lr{HCE}}
ارائه‌دهندگان خدمات را قادر می‌سازد تا مشکلات مدل 
{\normalsize \lr{SE}}
و چالش‌های یکی کردن 
	 	\LTRfootnote{Integration}
را حل و رفع کنند.
در حقیقت در این روش اطلاعات ذخیره شده بر روی تراشه‌های 
{\normalsize \lr{SE}}
بر روی فضای ابری قرار می‌گیرند و به مانند این است که 
{\normalsize \lr{SE}}
ها از روی گوشی به سرورهای 
{\normalsize \lr{HCE}}
منتقل شده‌اند. شکل 
\ref{fig:hce}
زیر ساخت 
{\normalsize  \lr {HCE}}
را نشان می‌دهد.

\begin{figure}[h]
	\centering
	\includegraphics[height=5cm]{images/hce}
	\caption{{\footnotesize \lr{Host Card Emulation}}}
	\label{fig:hce}
\end{figure}

\subsection{پیدایش تکنولوژی {\normalsize\lr{HCE}}} 
{\normalsize \lr{GSMA}}
و 
{\normalsize \lr{Consult Hyperion}}
در ماه ژانویه‌ی سال ۲۰۱۴ مقاله‌ای برای بانک‌ها و گردانندگان موبایل به منظور فهمیدن راه‌های
{\normalsize \lr{‌HCE}}
و 
{\normalsize \lr{SE}}
منتشر کرد. در فوریه‌ی همان سال 
{\normalsize \lr{MasterCard}}
و 
{\normalsize \lr{Visa}}
پشتیبانی خود از تکنولوژی 
{\normalsize \lr{HCE}}
را خبر دادند. به همراه آن مشخصات فنی برای این تکنولوژی نیز منتشر شد.  از تاریخ آپریل ۲۰۱۴ فقط برای 
سرویس 
{\normalsize \lr{Google Wallet}}
ممکن بود تا پرداخت 
{\normalsize \lr{NFC}}
خود را از راه 
{\normalsize \lr{HCE}}
بدون نیاز به 
{\normalsize \lr{SE}}  
انجام دهد. در سال ۲۰۱۵ شرکت مایکروسافت پشتیبانی از 
{\normalsize \lr{HCE}}
را در سیستم‌عامل ویندوز ۱۰ خود گنجاند. 

\subsection{فواید استفاده از تکنولوژی {\normalsize \lr{HCE}}}
\subsubsection{استقلال}
		با استقرار سرویس‌ها بر 
		{\normalsize \lr{HCE}}
		هیچ نیازی به واسط‌ها برای دسترسی به 
		{\normalsize \lr{SE}}
وجود ندارد. این امر باعث کم شدن خلاء میان ارائه‌دهنده‌ی نرم‌افزار و مشتری می‌شود. 

\subsubsection{یکی شدن آسان‌تر با شخص ثالث}					
در اختیار داشتن کنترل 
{\normalsize \lr{SE}}			
	سهولت یکی شدن آسان‌تر با شخص ثالث را به همراه خواهد داشت.
\subsubsection{هزینه‌های پایین‌تر}				
	به دنبال استفاده از تکنولوژی
	{\normalsize \lr{HCE}}،
	هزینه‌های یکی‌ کردن سرویس 
	{\normalsize \lr{SE}}
	وجود نخواهند داشت. 		
					
\subsubsection{استفاده از چندین کارت}
					از آنجایی که سیستم ذخیره‌سازی فیزیکی 
					{\normalsize \lr{SE}}
					محدود است، با استفاده از 
					{\normalsize \lr{HCE}}
		و استفاده از فضای ابری این محدودیت برای ذخیره‌سازی اطلاعات کارت‌ها رفع می‌شود و تعداد کارت بیشتری می‌تواند مورد پشتیبانی قرار بگیرد
	\cite{hcese}			.

		%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		\chapter{بررسی نحوه‌ی کار سرویس‌های   {\Large\lr{Apple Pay} }  و   {\Large\lr{Android Pay} }}\label{comparison}
		در این فصل به نحوه‌ی کار سرویس 
							{\normalsize \lr{Apple Pay}} 
		و 
							{\normalsize \lr{Android Pay}}
	از دید فنی پرداخته خواهد شد. سپس،  چگونگی استفاده‌ی هر دو سرویس از تکنولوژی 
						{\normalsize \lr{Tokenisation}} 
	بررسی خواهد شد. به عنوان مطرح‌ترین کیف پول الکترونیکی،   سرویس 
						{\normalsize \lr{Apple Pay}}
 بطور کامل مورد بررسی خواهد گرفت و در انتها به مقایسه‌ی دو سرویس و مزایا و معایب هر کدام پرداخته می‌شود.
 
 \section{{\large\lr{Apple Pay}} }
	 با استفاده از
	 						{\normalsize \lr{Apple Pay}}
کاربران می‌توانند با  دستگاه‌های 
{\normalsize \lr{iOS}}
	پشتیبانی شده و 
	{\normalsize \lr{Apple Watch}}
	اقدام به پرداخت امن و راحت بکنند. 
انجام خرید توسط این سرویس بسیار ساده است و برای تأمین امنیت آن از قابلیت‌های نرم‌افزاری و سخت‌افزاری استفاده شده است.

{\normalsize \lr{Apple Pay}}
همچنین برای محافظت از اطلاعات شخصی کاربران نیز طراحی شده است. اطلاعات تراکنش‌های انجام شده توسط 
{\normalsize \lr{Apple Pay}}
ذخیره نمی‌شوند و این اطلاعات فقط بین کاربر پذیرنده و صادر کننده کارت رد‌‌ و بدل خواهد شد.

\subsection{اجزای {\normalsize \lr{Apple Pay}} }
 
 \subsubsection{{\small \lr{Secure Element}}}
 {\normalsize \lr{Secure Element}}
 یک استاندارد صنعتی و یک تراشه‌ی گواهی شده
 					\LTRfootnote{certified Chip}
 مي‌باشد که تحت پلتفورم 
 {\normalsize \lr{Java Card}}
 است و منطبق با نیازمندی‌های صنعت مالی برای پرداخت‌های الکترونیکی می‌باشد.
 
  \subsubsection{{\small \lr{NFC Controller}}}
  {\normalsize \lr{NFC Controller}}
  پروتکل‌های مربوط به 
   {\normalsize \lr{NFC}}
   را مدیریت می‌کند و ارتباط دهنده بین پردازنده‌ی نرم‌افزار 
    					\LTRfootnote{Application Processor}
  و 
   {\normalsize \lr{Secure Element}}،   و همچنین ارتباط دهنده بین 
    {\normalsize \lr{Secure Element}}
    و ترمینال
     {\normalsize \lr{POS}} 
         					\LTRfootnote{Point-of Sale terminal}
      می‌باشد.
      
        \subsubsection{{\small \lr{Wallet}}}
        از
           {\normalsize \lr{wallet}}
           برای اضافه کردن و مدیریت کارت‌های اعتباری، بدهی و جایزه و همچنین انجام پرداخت‌ها از راه سرویس 
              {\normalsize \lr{Apple Pay}}
              استفاده می‌شود.
              کاربران می‌توانند اطلاعات مربوط به کارت خود،  صادر کننده‌ی کارت،   تراکنش‌های انجام شده‌ی اخیر و سیاست‌های حریم‌شخصی 
         					\LTRfootnote{privacy policy}              
              بانک خود را مشاهده کنند.
 
         \subsubsection{{\small \lr{Secure Enclave}}}
                       {\normalsize \lr{Secure Enclave}}
    بر روی
               {\normalsize \lr{iPhone}} و
                          {\normalsize \lr{iPad}}،
                                     {\normalsize \lr{Secure Enclave}}
    فرآیند احراز هویت کاربر را برعهده دارد،  و قادر می‌سازد که یک تراکنش صورت پذیرد و داده‌ی اثرانگشت مورد استفاده برای تکنولوژی 
               {\normalsize \lr{TouchID}}
               را فراهم می‌کند. 
               
   بر روی 
              {\normalsize \lr{Apple Watch }}
              ، دستگاه ممکن است نیاز به باز کردن قفل داشته باشد، و کاربر باید کنار انتهای آن‌را دوبار کلیک کند. این عمل دوبار کلیک کردن تشخیص داده می‌شود و به 
                         {\normalsize \lr{Secure Element}}
                      مستقیما   ارسال می‌شود،   بدون اینکه از پردازنده‌ی نرم‌افزار عبور کند.
                      
      \subsubsection{سرورهای{\small \lr{Apple Pay }}} 
      سرورهای 
   {\normalsize \lr{Apple Pay}}
   وضعیت کارت‌های اعتباری و بدهی در 
   {\normalsize \lr{Wallet}}
   و 
   {\normalsize \lr{Device Account Number}}
   در 
   {\normalsize \lr{Secure Elemetn}}
   را مدیریت می‌کنند. این سرورها هم با دستگاه‌‌های کاربران و هم با سرورهای شبکه‌ی پرداخت ارتباط برقرار می‌کنند.
   سرور‌های 
   {\normalsize \lr{Apple Pay}}
   همچنین مسئول رمزنگاری دوباره‌ی گواهی‌های پرداخت 
         					\LTRfootnote{Payment Credentials}      
         					برای پرداخت درون نرم‌افزار           
   هستند. 
               
    \subsection{چگونگی استفاده {\small \lr{Apple Pay }} از {\small \lr{Secure Element }}  ‌ }           
    در 
                  {\normalsize \lr{Secure Element}}
                  ،               {\normalsize \lr{applet }} های طراحی شده‌ای  
                  برای مدیریت 
                                {\normalsize \lr{Apple Pay}}
                                ذخیره شده است و همچنین شامل 
                                              {\normalsize \lr{applet}} های پرداخت که از طرف شبکه‌ی پرداخت گواهی شده است،  می‌باشد. 
                                              داده‌ی کارت اعتباری و یا بدهی که از شبکه‌ی پرداخت و یا صادر کننده‌های کارت ارسال می‌شوند به صورت رمزگذاری شده درون این 
                                                            {\normalsize \lr{applet}} ها 
     ذخیره می‌شوند. رمزنگاری توسط کلیدهایی صورت می‌گیرد که توسط شبکه‌ی پرداخت و دامنه‌ی امنیتی 
                   {\normalsize \lr{applet}}ها 
                   شناخته شده هستند. این داده‌ها درون 
                                 {\normalsize \lr{applet}} ها 
                                 ذخیره می‌شوند و توسط قابلیت‌های امنیتی
                                               {\normalsize \lr{Secure Element}}
                                               محافظت می‌شوند.
   در هنگام انجام یک تراکنش،  ترمینال مستقیما با 
                 {\normalsize \lr{Secure Element}}
                 از راه
                               {\normalsize \lr{NFC Controller}}
                               بر روی یک گذرگاه اختصاصی ارتباط برقرار می‌کند.
                               
  
   \subsection{چگونگی استفاده {\small \lr{Apple Pay }}  از {\small \lr{NFC Controller }} }                                 
   به عنوان درگاهی به 
   {\normalsize \lr{Secure Element}}
   ،  {\normalsize \lr{NFC Controller}}
   از اینکه تمامی تراکنش‌های پرداخت بدون تماس به درستی به ترمینال 
   {\normalsize \lr{POS}}
   هدایت می‌شوند، اطمینان حاصل می‌کند.
   تنها درخواست‌هایی که از طرف میدان ترمینال توسط 
   {\normalsize \lr{NFC Controller}}
   	می‌آیند به عنوان پرداخت بدون تماس علامت‌گذاری می‌شوند.
   	
   	بعد از اینکه اجازه‌ی پرداخت توسط کاربر با استفاده از 
   	{\normalsize \lr{Touch ID}}
   	و یا کلمه‌ی عبور 
   	\LTRfootnote{Passcode}
   	و یا در 
   	{\normalsize \lr{Apple Watch}} با باز کردن قفل و سپس دوبار کلیک کردن گوشه‌ی انتهایی،  داده شد، پاسخ‌های مربوط به پرداخت بدون تماس توسط 
   	{\normalsize \lr{applet}} های پرداخت 
   	که درون 
   	{\normalsize \lr{Secure Element}}
   	قرار دارند فقط و فقط از طریق 
   	{\normalsize \lr{NFC controller}}
   	به میدان 
   	{\normalsize \lr{NFC}}
   	مسیردهی می‌شوند. بنابراین اطلاعات ردوبدل شده در پرداخت بدون تماس از راه 
   	   	{\normalsize \lr{NFC}}
   	   	فقط در میدان 
   	   	   	{\normalsize \lr{NFC}}
   	  محلی حاضر خواهد شد و این اطلاعات به هیچ عنوان از پردازنده‌ی نرم‌افزار عبور نخواهد کرد.
   	  در مقابل جزئیات اجازه‌ی پرداخت،  در پرداخت به شکل درون نرم‌افزاری،  بعد از رمزنگاری توسط سرورهای 
   	     	{\normalsize \lr{Apple Pay}}
   	   به پردازنده‌ی نرم‌افزار مسیردهی می‌شود.
   	   
   \subsection{نحوه‌ی اضافه شدن کارت‌های اعتباری و بدهی}
   	زمانی که کاربر کارت اعتباری یا بدهی خود را به 
   	   	   	   	{\normalsize \lr{Apple Pay}}
   	 اضافه می‌کند،
   	    	   	   	{\normalsize \lr{Apple }} 
   	 اطلاعات کارت به همراه دیگر اطلاعات مثل اطلاعات حساب کاربر و دستگاه وی را به صادر کننده‌ی کارت به طور امن ارسال می‌کند. با استفاده از این اطلاعات صادرکننده‌ی کارت تعیین می‌کند که آیا این کارت می‌تواند به 
   	    	   	   	{\normalsize \lr{Apple Pay}}
   	    	   	   اضافه شود.
   	    	   	   
   	{\normalsize \lr{Apple Pay}} 
   	از سه فراخوانی سمت سرور برای ارتباطات ارسال و دریافت با صادرکننده‌ و یا شبکه به منظور فرآیند اضافه کردن کارت استفاده می‌کند:
   	\begin{itemize}
   		\item[-]    	{\normalsize \lr{Required Fields}}
   		\item[-] 	   	{\normalsize \lr{Check Card}}
   		\item[-]	   	{\normalsize \lr{Link and Provision}}  
   	\end{itemize}
   	      صادرکننده کارت و یا شبکه پرداخت از این فراخوانی‌ها به منظور اعتبارسنجی و تایید و اضافه کردن کارت‌ها به 
   	         	{\normalsize \lr{Apple Pay}} 
   	         	استفاده می‌کنند.
  تمامی ارتباطات 
     	{\normalsize \lr{Client-Server}} 
     	از طریق پروتکل 
     	   	{\normalsize \lr{SSL}} 
     	   	رمزگذاری می‌شوند.       					       
     	   	
   شماره‌ی کارت‌ها هیچکدام به طور کامل نه بر روی سرور‌های 
      	{\normalsize \lr{Apple}} 
      	و نه بر روی دستگاه‌ها ذخیره نمی‌شوند. در عوض یک 
      	   	{\normalsize \lr{Device Account Number}}
    ساخته می‌شود، رمزنگاری می‌شود و بر روی
       	{\normalsize \lr{Secure Element}}
       	ذخیره می‌شود. 
       	      	         	{\normalsize \lr{Apple}} 
       	      	         	از اصطلاح 
       	      	         	      	   	{\normalsize \lr{Device Account Number}}
       	      	         	      	   	به جای 
       	      	      	{\normalsize \lr{Token}}          	      	   	
       	      	   استفاده می‌کند.
       	این شماره بطوری رمزنگاری می‌شود که 
       	   	{\normalsize \lr{Apple}} به آن دسترسی نداشته باشد.
       	   	 این شماره منحصر به فرد است و با شماره‌های کارت اعتباری و بدهی متفاوت هستند. 
       	   	        	   	{\normalsize \lr{Device Account Number}}
 در 
       	   	        	   	       	{\normalsize \lr{Secure Element}}
   قرار دارند و از 
          	{\normalsize \lr{iOS}}
          	و 
          	       	{\normalsize \lr{WatchOS}}
 کاملا ایزوله شده اند  و هیچ گاه بر روی سرورهای 
        	{\normalsize \lr{Apple}}
        	و یا بر روی 
        	       	{\normalsize \lr{iCloud}}
        	       	ذخیره نمی‌شوند.        	        	    	   	        	   	 
        	       	
برای استفاده کارت‌ها با 
       	{\normalsize \lr{Apple Watch}}
   از راه اضافه کردن کارت‌ها بواسطه‌ی نرم‌افزار 
          	{\normalsize \lr{Apple Watch}}
          	بر روی 
          	       	{\normalsize \lr{iPhone}}
انجام می‌پذیرد. اضافه کردن یک کارت برای 
       	{\normalsize \lr{Apple Watch}} 
       	نیازمند این است که ساعت در فاصله‌ی مجاز محدوده‌ی بلوتوث قرار داشته باشد. کارت‌ها به صورت خاص برای 
       	       	{\normalsize \lr{Apple Watch}} 
 ثبت می‌شوند و دارای 
          	   	        	   	{\normalsize \lr{Device Account Number}}    	       	
       	خودشان هستند،  که بر روی 
       	{\normalsize \lr{Secure Element}}  
       	درون 
       	{\normalsize \lr{Apple Watch}}
       	ذخیره می‌شوند.
       	
       	سه راه برای تعریف کارت‌های اعتباری و بدهی به 
       	{\normalsize \lr{Apple Pay}}
       	وجود دارد: 
       \begin{itemize}
       	\item[-] اضافه کردن کارت‌ها بصورت دستی
       	\item[-] اضافه کردن کارت‌ها از روی فایل از حساب {\normalsize \lr{iTunes}} 
       	\item[-] اضافه کردن کارت‌ها از راه نرم‌افزار صادرکننده‌ی کارت
       \end{itemize}

\subsubsection{اضافه کردن کارت‌ها بصورت دستی}
برای اضافه کردن کارت‌ها بصورت دستی ، اسم کارت، شماره کارت، تاریخ انقضاء و 
{\normalsize \lr{CVV2}} 
برای سهولت فرآیند استفاده می‌شوند. کاربران از راه 
{\normalsize \lr{Settings}} 
، نرم‌افزار
{\normalsize \lr{Wallet}}
و یا 
{\normalsize \lr{Apple Watch}} 
می‌توانند این اطلاعات را تایپ کنند و یا از راه دوربین
{\normalsize \lr{iSight}} 
اطاعات را ارسال کنند.
زمانی که دوربین اطلاعات کارت را دریافت می‌کند،
{\normalsize \lr{Apple}}
تلاش می‌کند اطلاعات لازم را از آن بدست آورد. زمانی که تمامی فیلد‌های مربوطه  توسط فرآیند 
{\normalsize \lr{Check Card}}
بازرسی شدند و 
کامل شدند،  اطلاعات به صورت رمزنگاری شده به سرور‌های 
{\normalsize \lr{Apple Pay}} ارسال می‌شوند.

اگر طی این فرآیند یک شناسنده مربوط به شرایط و 	ضوابط دریافت شد ، 
{\normalsize \lr{Apple}}
آن را دانلود می‌کند و شرایط و ضوابط صادر کننده‌ی مربوطه را به کاربر نشان می‌دهد. در صورت تأیید شرایط توسط کاربر 
{\normalsize \lr{Apple}}
شناسنده‌ی مربوط به شرایط و ضوابط را تحت فرآیند 
{\normalsize \lr{Link and Provision}}  
به صادرکننده ارسال می‌کند. به علاوه در طی فرآیند 
{\normalsize \lr{Link and Provision}}، 
{\normalsize \lr{Apple}} 
اطلاعاتی از دستگاه کاربر با صادرکننده کارت یا شبکه به اشتراک می‌گذارد،  اطلاعاتی در مورد 
{\normalsize \lr{iTunes}}
و فعالیت‌های 
{\normalsize \lr{App Store}}
، برای مثال آیا کاربر تراکنش‌هایی بلند مدت از 
{\normalsize \lr{iTunes}}
داشته است یا خیر، همچنین اطلاعاتی در مورد دستگاه کاربر برای مثال شماره‌ی تلفن،  اسم و مدل دستگاهی که کاربر از آن استفاده می‌کند، بعلاوه‌ی مکانی که کاربر در حین انجام اضافه کردن کارت در آن لحظه قرار دارد. 
با استفاده از این اطلاعات بانک‌صادرکننده‌ی کارت تعیین می‌کند که آیا کارت اضافه شود و یا نه. 

در  نتیجه‌ی فرآیند 
{\normalsize \lr{Link and Provision}} 
دو اتفاق زیر رخ می‌دهد:
\begin{itemize}
	\item[-] دستگاه شروع به دانلود  {\normalsize \lr{pass Wallet file }}   می‌کند، که نمایان کننده‌ی کارت اعتباری و یا بدهی می‌باشد.
	\item[-] دستگاه شروع به ذخیره‌ی کارت درون {\normalsize \lr{Secure Element}} می‌کند. 
\end{itemize}


{\normalsize \lr{pass Wallet}} 
حاوی 
{\normalsize \lr{URL}} ها
	برای دانلود 
	{\normalsize \lr{card art}}
	و اطلاعاتی مانند اطلاعات تماس و اطلاعات درباره‌ی صادرکننده می‌باشد. همچنین وضعیت فعلی را هم در اختیار دارد که شامل این است که آیا شخصی سازی 
	{\normalsize \lr{Secure Element}}
	کامل شده است یا خیر و یا اینکه آیا اعتبارسنجی اضافه‌ی دیگری نیاز هست تا انجام پرداخت میسر شود.
	
\subsection{اجازه‌ی پرداخت}

{\normalsize \lr{Secure Element}}
تنها زمانی اجازه‌ی انجام یک پرداخت را می‌دهد که اجازه از 
{\normalsize \lr{Secure Eclave}}
گرفته باشد، در واقع با تأیید کاربر که توسط 
{\normalsize \lr{Touch ID}} 
و یا کلمه‌ی عبور این اجازه صادر شده است. 
{\normalsize \lr{Touch ID}} 
روش پیش‌فرض در صورت در دسترس بودن است اما هر زمانی استفاده از کلمه‌ی عبور نیز ممکن است. بعد از سه تلاش ناموفق برای اثر انگشت کلمه‌ی عبور پیشنهاد داده می‌شود و بعد از پنج تلاش ناموفق کاربر فقط از طریق کلمه‌ی عبور می‌تواند پرداخت را انجام دهد. 

ارتباطات بین 
{\normalsize \lr{Secure Element}}
 و
 {\normalsize \lr{Secure Eclave}}
  از راه یک واسط سریال صورت می‌گیرد، و اینکه 
  {\normalsize \lr{Secure Element}} 
  به 
  {\normalsize \lr{NFC Controller }}
  و به مراتب به پردازنده نرم‌افزار متصل شده است. اگرچه 
  {\normalsize \lr{Secure Element}}
  و
  {\normalsize \lr{Secure Eclave}}
  بصورت مستقیم بهم متصل نشده‌اند، این دو می‌توانند با استفاده‌ از یک کلید به اشتراک گذاشته که در حین فرآیند تولید تهیه شده اند ارتباط امنی داشته باشند. 
   	      				 
  \subsection{کد امنیتی پویای مخصوص هر تراکنش  } 	      			
تمامی تراکنش‌ها که از 
  {\normalsize \lr{applet }} ها
  نشأت می‌گیرند شامل کد امنیتی پویای مخصوص هر تراکنش 
     	\LTRfootnote{Transaction-specific dynamic security code}
   همراه با یک 
     {\normalsize \lr{Device Account Number}}
     می‌باشند. این کد یکبار مصرف با استفاده از یک شمارنده‌ای که در هر تراکنش به آن یک واحد اضافه می‌شود  و با استفاده از یک کلیدی که در حین فرآیند اضافه شدن کارت درون 
       {\normalsize \lr{applet}}ها
       قرار دارد،   محاسبه می‌شود. این کلید توسط شبکه‌ی 	پرداخت و یا صادر کننده‌های کارت قابل تشخیص می‌باشد. بر اساس برنامه‌های مختلف پرداخت ممکن است داده‌های دیگری نیز در محاسبه‌ی این کد نقش داشته باشند. 
       
       این کدهای امنیتی به شبکه‌ی پرداخت و صادرکننده‌های کارت ارسال می‌شوند، تا اجازه‌ی انجام تراکنش صادر شود. طول این کد امنیتی بر اساس نوع تراکنشی که در حال انجام است ممکن است فرق داشته باشد. 
       
 \subsection{پرداخت از راه {\small \lr{NFC }} }
 اگر 
 {\normalsize \lr{iPhone}}
 روشن باشد و در نزدیکی میدان 
 {\normalsize \lr{NFC}}
 قرار گیرد،  به کاربر کارت اعتباری و یا بدهی مربوطه،  یا کارت پیش‌فرض که از طریق تنظیمات مدیریت شده، نشان داده می‌شود. 
 کاربر می‌تواند به داخل نرم‌افزار 
 {\normalsize \lr{Wallet }} 
 برود و کارت اعتباری و یا بدهی مورد نظر را انتخاب کند، و یا اگر تلفن همراه قفل است دو بار دکمه‌ی 
 {\normalsize \lr{‌Home}} 
 را فشار دهد. 
 
 در مرحله‌ی بعد کاربر باید با استفاده از اثر انگشت و یا کلمه‌ی عبور احراز هویت را انجام دهد. هیچ اطلاعات پرداختی بدون احراز هویت کاربر ارسال و جابجا نخواهد شد. 
 
 بعد از انجام احراز هویت،
 {\normalsize \lr{Device Account Number}} 
 و یک  کد امنیتی پویای مخصوص هر تراکنش برای پردازش پرداخت مورد استفاده قرار می‌گیرد. نه 
  {\normalsize \lr{‌Apple }}
  و نه دستگاه کاربر،  شماره‌ی کارت اعتباری و یا بدهی را به پذیرنده ارسال نخواهند کرد. 
   {\normalsize \lr{‌Apple}}
   ممکن است اطلاعات بدون هویت تراکنش مانند زمان تقریبی تراکنش و مکان تراکنش را دریافت کند، که به بهتر شدن 
    {\normalsize \lr{‌Apple Pay}} 
    و دیگر سرویس‌های 
     {\normalsize \lr{‌Apple}} 
     کمک می‌کند.  
   
   \subsection{پرداخت درون نرم‌افزاری}
از 
     {\normalsize \lr{‌Apple Pay}}
     می‌توان برای پرداخت درون‌ نرم‌افزار نیز  استفاده کرد.  زمانی که یک نرم‌افزار  تراکنش پرداخت از راه 
      {\normalsize \lr{‌Apple Pay}} 
      را شروع می‌کند،  سرورهای 
      {\normalsize \lr{‌Apple Pay}}
      قبل از اینکه پذیرنده اطلاعات تراکنش را بگیرد،  بصورت رمزگذاری شده تحویل می‌گیرند. سپس 
          {\normalsize \lr{‌Apple}} 
   اطلاعات تراکنش  را دوباره با کلیدی که از پذیرنده در اختیار دارد رمزنگذاری می‌کند. 
        {\normalsize \lr{‌Apple Pay}} 
        همچنین اطلاعات  تراکنش همانند مقدار تقریبی خرید را نگهداری می‌کند. این اطلاعات به کاربر بازگردانده نخواهد شد و هرگز مشخص نمی‌کند که چه کالایی خریداری شده‌ است. 
        
زمانی که یک نرم‌افزار درخواست پرداخت را می‌دهد،  یک 
{\normalsize \lr{‌API}} 
    را فراخوانی که تعیین می‌کند دستگاه کاربر 
    {\normalsize \lr{‌Apple Pay}} 
   را پشتیبانی می‌کند یا خیر، اینکه آیا کاربر از قبل کارت‌های اعتباری و بدهی خود را اضافه کرده است.
   نرم‌افزار هر قسمت از اطلاعات که برای تکمیل  تراکنش لازم است  را درخواست می‌دهد. این اطلاعات ممکن است شامل صورت حساب و آدرس ارسال، و اطلاعات تماس باشد. سپس نرم‌افزار درخواستی به 
   {\normalsize \lr{‌iOS}} 
   مبنی بر اطلاعات لازم برای نرم‌افزار و همچنین دیگر اطلاعات مورد نیاز مانند کارت را ارسال می‌کند. 

  در این زمان نرم‌افزار اطلاعاتی همچون کد ناحیه پستی و شهر و استان را به منظور محاسبه‌ی هزینه‌ی ارسال دریافت می‌کند. تا زمانی که کاربر اجازه‌ی پرداخت را توسط 
  {\normalsize \lr{‌Touch ID}} 
  و یا کلمه‌ی عبور صادر نکرده است،  اطلاعات بصورت کامل به نرم‌افزار انتقال داده نخواهد شد. زمانی که اجازه‌ی 	پرداخت توسط کاربر صادر شود،  اطلاعات به کاربر منتقل خواهد شد. 
  
  زمانی که کاربر اجازه‌ی پرداخت را می‌دهد، یک فرخوانی به سرورهای 
  {\normalsize \lr{‌Apple Pay}} 
  به منظور کسب کد رمزگذاری لحظه‌ای 
       	\LTRfootnote{Cryptographic nonce}
     داده می‌شود. این کد به همراه دیگر اطلاعات تراکنش به 
      {\normalsize \lr{‌Secure Element}} 
      داده می‌شوند تا گواهی پرداخت 
             	\LTRfootnote{Payment Credential}
      تولید شود. سپس این گواهی توسط یک کلید 
       {\normalsize \lr{‌Apple}} 
    رمزنگاری می‌شود،  از 
     {\normalsize \lr{‌Secure Element}} 
     خارج می‌شوند 
    و به سمت سروهای 
     {\normalsize \lr{‌Apple Pay}} 
     ارسال می‌شوند. سپس اطلاعات گواهی رمزگشایی می‌شوند و کد لحظه‌ای درون گواهی با کد لحظه‌ای ارسالی از طرف 
          {\normalsize \lr{‌Secure Element}} 
    به منظور بررسی صحت آن بررسی می‌شود و گواهی پرداخت با استفاده از کلید پذیرنده که توسط شناسنده‌ی پذیرنده قابل دسترسی است دوباره رمزنگاری می‌شود و  توسط 
         {\normalsize \lr{‌API}} 
         موجود به دستگاه کاربر بازگردانده می‌شود.  سپس نرم‌افزار موجود، آن را به سیستم‌های پذیرنده به منظور پردازش عملیات پرداخت می‌فرستد. به منظور پردازش گواهی پرداخت،  پذیرنده با استفاده از کلید خصوصی 
               	\LTRfootnote{Private Key}       
         خود می‌تواند آن را رمزگشایی کند. همراه با این،  امضای دیجیتالی که از سمت سرورهای 
         {\normalsize \lr{‌API}} 
                به پذیرنده ارسال شده‌اند، این اجازه را به پذیرنره می‌دهد که از صحت گواهی پرداخت و اینکه پذیرنده درست است اطمینان حاصل کند
      \cite{iossecurity}.
      
      \section{{\large\lr{Android Pay}}}
 نحوه‌ی کار کلی سرویس 
       	{\normalsize \lr{Android Pay}}
       	همانند سرویس
       	      	{\normalsize \lr{Apple Pay}}
       	با تفاوت‌هایی می‌باشد. سرویس 
       	      	{\normalsize \lr{Android Pay}} 
       	      	به جای استفاده از تراشه‌ای بر روی تلفن همراه، خواه تراشه‌ای بر روی سیم‌کارت و یا تراشه‌ای بر روی  تلفن‌ همراه، از تکنولوژی
       	      	      	{\normalsize \lr{HCE}} 
       	      	      	استفاده می‌کند. 
      
      مراحل کار سرویس 
            	{\normalsize \lr{Android Pay}} 
            	به صورت زیر می‌باشد:
     \begin{enumerate}
     	\item 
     	کاربر گزینه‌ی 
     	{\normalsize \lr{Buy With Android Pay}} 
     	را انتخاب می‌کند. با استفاده از رابط برنامه‌نویسی گوگل، پذیرنده درخواست شیء
     	{\normalsize \lr{Masked Wallet}} 
     	را برای نمایش مشخصات کاربر و اطلاعات کارت، به کاربر را می‌دهد.
     	\item 
     	کاربر پرداخت را تأیید می‌کند. پذیرنده با استفاده از رابط برنامه‌نویسی گوگل، درخواست شیء
     	{\normalsize \lr{Full Wallet}} 
     	را می‌دهد. این درخواست حاوی کلید عمومی 
     	               	\LTRfootnote{Public Key}       
     	پذیرنده نیز می‌باشد. 
     	\item 
     	گوگل درخواست 
     	{\normalsize \lr{Token}} 
     	شبکه‌ی پرداخت و 
     	{\normalsize \lr{Cryptogram}} 
     	را به شبکه‌ی پرداخت می‌دهد
     (
     {\normalsize \lr{Cryptogram}} 
     معادل 
     {\normalsize \lr{Transaction-specific dynamic security code}} 
     در سرویس
     {\normalsize \lr{Apple Pay}} 
     می‌باشد
     ).
     \begin{enumerate}
     	\item
     	شبکه‌ی پرداخت درخواست 
     	     {\normalsize \lr{Token}} 
     	     پرداخت 
     	     و 
     	          {\normalsize \lr{Cryptogram}} 
     	          را به 
     	               {\normalsize \lr{Token Service Provider}}  
     	           شبکه    می‌دهد.
     \item
     شبکه
                         {\normalsize \lr{Token Service Provider}}
                         درخواست 
                              {\normalsize \lr{Token}} پرداخت را به 
                              صادر کننده می‌دهد. 
     \item 
     صادر کننده‌ 
          {\normalsize \lr{Token}} 
          شبکه‌ی پرداخت و
               {\normalsize \lr{Cryptogram}} 
           را به 
               {\normalsize \lr{Token Service Provider}} 
               شبکه‌ می‌دهد.                    
     \item
     شبکه‌ی 
          {\normalsize \lr{Token Service Provider}} 
          ،      {\normalsize \lr{Token}} 
          و 
               {\normalsize \lr{Cryptogram}} 
               را به شبکه‌ی پرداخت تحویل می‌دهد.                       
     \end{enumerate}
	 \item
	شبکه‌ی پرداخت 
	     {\normalsize \lr{Token}} پرداخت 
	     و 
	          {\normalsize \lr{Cryptogram}} 
	          را به گوگل ارسال می‌کند. 
	 \item
	 گوگل یک بسته‌ی اطلاعاتی که با استفاده از کلید عمومی ارسال شده در درخواست
	      {\normalsize \lr{Full Wallet}}
	       و آن‌را در جواب رابط نرم‌افزاری گوگل می‌گنجاند. 
	  \item
	  نرم‌افزار 
	       {\normalsize \lr{Android Pay}}      
	       با استفاده از فراخوانی تابع
	            {\normalsize \lr{onActivityresult()}} 
	               داده‌ی پرداخت رمزنگاری شده را به سرور پذیرنده ارسال می‌کند.
	   \item
	   پذیرنده با استفاده از زیر ساخت خود، و یا با استفاده از 
     {\normalsize \lr{SDK}}
     یک پردازنده‌ی پرداخت، شروع به پردازش تراکنش می‌کند
          \cite{androidpay} .        
     \end{enumerate}      	
     

		
		%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		
		\chapter{طراحی و پیاده‌سازی نرم‌افزار پرداخت سمت سرور}\label{serverimplementation}
در این فصل پیاده‌سازی نرم‌افزار سمت سرور 
 مورد بررسی قرار خواهد گرفت و توضیح کلی در مورد تکنولوژی‌های مورد استفاده در پیاده‌سازی همچون 
         {\normalsize \lr{‌RESTful Services}}،
                  {\normalsize \lr{‌servlet}} ها
                  و 
                           {\normalsize \lr{‌Hibernate}}
                              صحبت خواهد شد. 
                              
   \section{ساختار کلی}                
  زبان برنامه‌نویسی به کار رفته در سمت سرور زبان
  {\normalsize\lr{Java}}
  می‌باشد.
  نحوه‌ی کار نرم‌افزار سمت سرور بدین شکل می‌باشد که،  در سمت سرور وب‌سرویس‌های پیاده‌سازی شده 
  آماده‌ی سرویس دهی به درخواست‌های کلاینت‌ها می‌باشند. وب‌سرویس‌ها توسط قالب‌کاری 
           {\normalsize \lr{‌servlet}} 
   پیاده‌سازی شده‌اند. پس از اینکه وب‌سرویس‌ها درخواست را از کلاینت‌ها دریافت کردند، 
   محتوای مورد نیاز را از پایگاه داده که 
            {\normalsize \lr{‌MySQL}} 
            می‌باشد با استفاده از تکنولوژی                                     
                     {\normalsize \lr{‌Hibernate}} 
واکاوی می‌کنند و در قالب
         {\normalsize \lr{‌JSON}}\LTRfootnote{JavaScript Object Notation}،       
         محتوای مناسب را به کلاینت‌ها تحویل می‌دهند. 
		در بخش‌های به توضیح تکنولوژی‌های ذکر شده و نحوه‌ی پیاده‌سازی آن‌ها پرداخته خواهد شد.
		
		کلاس‌هایی در قالب 
		{\normalsize\lr{Controller}}
		برای دریافت و پردازش درخواست‌های کلاینت‌ها تعبیه شده، و کلاس‌هایی در قالب
		{\normalsize\lr{Model}}
		به منظور ارتباط با پایگاه داده و عملیات جستجو در آن‌ را انجام می‌دهند. 
		
	\section{{\large\lr{Web Service}}}
اگرچه کلمه‌ی 
{\normalsize\lr{Web Service}}
معانی مختلفی را شامل می‌شود، اما می‌توان بدین شکل تعریف کرد. یک 
{\normalsize\lr{Web Service}}
شامل یک سرویس و یک کلاینت که همچنین به عنوان درخواست دهنده یا مصرف‌کننده نیز شناخته می‌شود. همانطور که  اسم 
{\normalsize\lr{Web Service}}
بیان می‌کند، یک 
{\normalsize\lr{Web Service}}
نوعی نرم‌افزار بصورت وبی درآمده است و بطور معمول از پروتکل 
{\normalsize\lr{HTTP}}
استفاده می‌کند. 
		
		{\normalsize\lr{Web Service}} ها
		می‌توانند توسط زبان‌های برنامه‌نویسی متفاوتی برنامه‌نویسی شوند. راه آشکار برای پیاده‌سازی یک 
		{\normalsize\lr{Web Service}}
		توسط یک 
		{\normalsize\lr{Web Server}}
		می‌باشد. یک کلاینت 
		{\normalsize\lr{Web Service}}
	نیاز دارد بر روی یک ماشین که دسترسی شبکه را دارد ،بر روی پروتکل
			{\normalsize\lr{HTTP}}
			اجرا شود. از دیدگاه فنی،  یک
					{\normalsize\lr{Web Service}} 
			یک سیستم نرم‌افزاری توزیع‌شده است که می‌تواند اجزایش بر روی دستگاه‌های از لحاظ فیزیکی مجزا مستقر شود. 
			مثالی را در نظر بگیرید که متشکل از یک 
					{\normalsize\lr{Web S‌erver}}
	که یک 
			{\normalsize\lr{Web Service}}
			را میزبانی می‌کند، و یک دستگاه تلفن همراه که یک نرم‌افزاری را میزبانی می‌کند که درخواست‌ها را به این 
					{\normalsize\lr{Web Service}}
					ارسال می‌‌کند. در شکل 
					\ref{fig:clientserver}
	ارتباط بین یک کلاینت و سرور نشان داده شده است. 
					
					\begin{figure}[h]
						\centering
						\includegraphics[height=3cm]{images/clientserver}
						\caption{یک {\footnotesize\lr{Web Service}} و کلاینت}
						\label{fig:clientserver}
					\end{figure}
یک 
		{\normalsize\lr{Web Service}}
		ممکن است از لحاظ معماری بسیار پیچیده‌تر باشد، بطوری که فرض کنید ، کلاینت‌ها بطور همزمان درخواست‌ها را ارسال می‌کنند، و خود 
				{\normalsize\lr{Web Service}}
				امکان دارد متشکل از چند 
						{\normalsize\lr{Web Service}}
						دیگر باشد. 					
					
{\normalsize\lr{Web Service}}ها 
در دو نوع متفاوت می‌باشند: 
\begin{itemize}
	\item[-] {\normalsize\lr{RESTful}}
	\item[-]{\normalsize\lr{SOAP}}
\end{itemize}
{\normalsize\lr{Web Service}} های 
بر پایه‌ی 
{\normalsize\lr{SOAP}}
    	\LTRfootnote{Simple Object Access Protocol}       
از 
{\normalsize\lr{XML}}
به عنوان ساختار محتوای تبادلی استفاده می‌کنند.  همچنین بیشتر برای طراحی‌های مستقل از پروتکل انتقال استفاده‌ می‌شوند. 
{\normalsize\lr{Web Service}} های 
بر پایه‌ی 
{\normalsize\lr{RESTful}}
              	\LTRfootnote{REpresentational State Transfer}       
برای از میان بردن پیچیدگی‌های 
{\normalsize\lr{Web Service}}
بوجود آمده‌اند.
{\normalsize\lr{REST}}
توسط دکتر 
{\normalsize\lr{Roy Fielding}}
که موضوع رساله‌ی دکتری وی بود مطرح شد. 
{\normalsize\lr{REST}}
و 
{\normalsize\lr{SOAP}}
کاملا از هم متفاوت هستند. 
{\normalsize\lr{SOAP}}
یک پروتکل ارسال پیام است و در واقع نحوه‌ی ارسال پیام‌‌ها را بیان می‌کند که پیام‌ها متون 
{\normalsize\lr{XML}}
هستند، اما 
{\normalsize\lr{REST}}
یک شیوه‌ای از معماری نرم‌افزار برای سیستم‌های مافوق رسانه‌ای توزیعی 
    	\LTRfootnote{distributed hypermedia system}،  سیستم‌هایی که در آن‌ها متون،  تصاویر گرافیکی، صدا و دیگر رسانه‌ها بر روی شبکه ذخیره می‌شوند، که از راه 
{\normalsize\lr{hyperlink}}
قابل دسترسی هستند. 
{\normalsize\lr{World Wide Web}}
مثالی روشن از یک چنین سیستمی است. در این وب ، 
{\normalsize\lr{HTTP}}
هم پروتکل انتقال است و هم سیستم پیام‌دهی، به این علت که درخواست‌ها 
    	\LTRfootnote{Request}       
و پاسخ‌های 
    	\LTRfootnote{Response}       
پیام‌های مدنظر هستند.

مزیت بسیار حائز اهمیت 
{\normalsize\lr{Web Service}} ها 
مستقل از زبان برنامه‌نویسی
    	\LTRfootnote{‌Language Neutral}       
 هستند، بدین معنی که برای مثال در سمت سرور 
{\normalsize\lr{Web Service}} ها 
به زبان 
{\normalsize\lr{Java}}
نوشته‌‌ شده‌اند اما می‌توان از طریق یک کلاینت که با استفاده از زبان 
{\normalsize\lr{Perl}}
برنامه‌نویسی شده با آن ارتباط برقرار کرد. 

رابط‌های برنامه‌نویسی متفاوتی برای پیاده‌سازی 
{\normalsize\lr{RESTful Web Service}} ها 
در زبان 
{\normalsize\lr{Java}}
وجود دارد که عبارتند از : 

\begin{itemize}
	\item [-]{\normalsize\lr{HttpServlet}}
	\item [-]{\normalsize\lr{JAX-RS}}
	که دارای پیاده‌سازی‌های مختلف است.
	\item [-]{\normalsize\lr{Restlet}}
	که مشابه با 
	{\normalsize\lr{JAX-RS}}
	می‌باشد.
	\item [-]{\normalsize\lr{JAX-WS}} 
	که به ندرت مورد استفاده قرار می‌گیرد
	\cite{webserviceoreilly}.
\end{itemize}



در این پروژه از قالب‌کاری 
{\normalsize\lr{Servlet}}
برای پیاده‌سازی 
{\normalsize\lr{Web Servicel}} ها 
و از 
{\normalsize\lr{Apache Tomcat}}
به عنوان سرور نرم‌افزار
    	\LTRfootnote{‌Application Server}       
استفاده شده ‌است.

\section{تشریح نحوه پیاده‌سازی}
	\subsection{بسته {\small\lr{Controllers}}}
	در این بسته 
	    	\LTRfootnote{Package}
،
{\normalsize\lr{Servlet}} های 
اصلی نرم‌افزار پیاده‌سازی شده‌اند. برای مثال کلاس‌هایی برای عملیات ورود کاربر، ثبت کاربر جدید، پیدا کردن محل حال حاضر کاربر بر اساس اطلاعات 
{\normalsize\lr{Beacon}}
و تأیید شماره‌ی کاربر توسط وب سرویس 
{\normalsize\lr{SMS}}،  که از کلاس
{\normalsize\lr{HttpServlet}}
ارث می‌برند، پیاده‌سازی شده است. 

\subsubsection{کلاس     {\small\lr{WhereIsBeacon}}}
این 
{\normalsize\lr{servlet}}
 به منظور پیدا کردن مکان فعلی کاربر پیاده‌سازی شده است. نحوه‌ی استفاده از این کلاس بدین شکل است: زمانی که کاربر در یک فروشگاه حضور پیدا می‌کند، با استفاده از تکنولوژی 
 {\normalsize\lr{iBeacon}}
 حضور کاربر کشف می‌شود. سپس سه مقدار 
 {\normalsize\lr{UUID}}
 و 
 {\normalsize\lr{Major}}
 و 
 {\normalsize\lr{Minor}}
 از 
 {\normalsize\lr{Beacon}}
 گرفته می‌شود و برای تعیین محل فعلی کاربر به این وب‌سرویس درخواستی ارسال می‌شود. در فصل 
 \ref{clientimplementation}
 به توضیح این تکنولوژی و مقادیر مربوطه پرداخته شده‌است. 
 
کد مربوط به این کلاس به شکل زیر می‌باشد: 
\begin{latin}
	\begin{verbatim}
	@WebServlet("/getstore")
	public class WhereIsBeacon extends HttpServlet {
	protected void doPost(HttpServletRequest request, 
	HttpServletResponse response) throws ServletException, 
	IOException {
	//set MIME type to JSON
	response.setContentType("application/json");
	ManageBeacon manageBeacon = new ManageBeacon((SessionFactory) 
	getServletContext().getAttribute("sessionfactoryobj"));
	String uuid = request.getParameter("uuid");
	int major =  Integer.parseInt(request.getParameter("major"));
	int minor = Integer.parseInt(request.getParameter("minor"));
	
	StoreEntity store = manageBeacon.getStore(uuid,major,minor);
	//respond to client
	if (store != null)
		{
	HttpSession session = request.getSession();
	session.setAttribute("currentstore",store);
	StoreResponse rsp = new StoreResponse(500,"store is 
	detected",store.getIdstore(),store.getName());
	Gson gson = new Gson();
	String jsonString = gson.toJson(rsp,StoreResponse.class);
	PrintWriter printWriter = response.getWriter();
	printWriter.println(jsonString);
	      	}
	else {
	StoreResponse storeResponse = new 
	StoreResponse(510,"The store could not be detected",0,null);
	Gson gson = new Gson();
	String jsonString = gson.toJson(storeResponse,StoreResponse.class);
	PrintWriter printWriter = response.getWriter();
	printWriter.println(jsonString);
	               	}
	        }
	}
	\end{verbatim}
\end{latin}
		
\noindent		
مرحله‌ی بعد از ارث‌بری کلاس
{\normalsize\lr{HttpServlet}}
پیاده‌سازی تابع
{\normalsize\lr{doPost}}
می‌باشد. درخواستی که از سمت کلاینت به سرور ارسال می‌شود، از متد 
{\normalsize\lr{‌POS}}
پروتکل 
{\normalsize\lr{HTTP}}
استفاده میکند. بنابراین برای در 
{\normalsize\lr{servlet}}
مورد نظر باید تابع 
{\normalsize\lr{doPost}}
پیاده‌سازی شود. 

با استفاده از قطعه کد زیر، مشخص می‌شود که نوع محتوایی که این وب سرویس بر‌می‌گرداند از چه نوعی است:‌
\begin{latin}
\begin{verbatim}
	response.setContentType("application/json");
\end{verbatim}
	
\end{latin}
تمامی پاسخ‌ها در این نرم‌افزار به فرمت
{\normalsize\lr{JSON}}
می‌باشند. 

در قطعه کد زیر مقادیر ارسالی توسط کاربر که در به عنوان پارامتر‌های درخواست هستند گرفته می‌شوند:
\begin{latin}
	\begin{verbatim}
String uuid = request.getParameter("uuid");
int major =  Integer.parseInt(request.getParameter("major"));
int minor = Integer.parseInt(request.getParameter("minor"));
	\end{verbatim}
	
\end{latin}
توسط قطعه کد زیر این مکان فعلی کاربر جستجو می‌شود : 
\begin{latin}
	\begin{verbatim}
	StoreEntity store = manageBeacon.getStore(uuid,major,minor);
	\end{verbatim}
	
\end{latin}

توسط قطعه کد زیر مکان فعلی کاربر در جلسه‌ی ایجاد شده برای کاربر ذخیره می‌شود: 
\begin{latin}
	\begin{verbatim}
HttpSession session = request.getSession();
session.setAttribute("currentstore",store);
	\end{verbatim}
	
\end{latin}
برای تبدیل کردن مقادیر ارسالی به معادل فرمت 
{\normalsize\lr{JSON}}
‌آن‌ها، کلاسی معادل فیلد‌های ارسالی به شکل 
{\normalsize\lr{Beans}}
 باید ساخته شود. کلاس استفاده شده برای جواب به شکل زیر می‌باشد: 
\begin{latin}
	\begin{verbatim}
	public class StoreResponse extends Response {
	int storeid;
	String storename;
	
	public StoreResponse(int resultcode, String metadata,
	 int storeid, String storename) {
	super(resultcode, metadata);
	this.storeid = storeid;
	this.storename = storename;
        	}
	
	public int getStoreid() {
	return storeid;
        	}
	
	public String getStorename() {
	return storename;
        	}
	
	public void setStoreid(int storeid) {
	this.storeid = storeid;
        	}
	
	public void setStorename(String storename) {
	this.storename = storename;
         	}
     	}
	
	\end{verbatim}
	
\end{latin}

شیءای همانند کد زیر برای تبدیل آن به معادل 
{\normalsize\lr{JSON}}
ساخته می‌شود:
\begin{latin}
	\begin{verbatim}
	StoreResponse rsp = new StoreResponse(500,"store is 
	detected",store.getIdstore(),store.getName());
	\end{verbatim}
	
\end{latin}
	برای تبدیل شیء ساخته شده به معادل 
	{\normalsize\lr{JSON}}
	آن به شکل زیر عمل می‌شود:
	\begin{latin}
		\begin{verbatim}
Gson gson = new Gson();
String jsonString = gson.toJson(rsp,StoreResponse.class);
		\end{verbatim}
		
	\end{latin}
برای ارسال رشته‌ی 
			{\normalsize\lr{JSON}}
			بدست‌آمده به کلاینت به شکل زیر عمل می‌شود: 
\begin{latin}
	\begin{verbatim}
		PrintWriter printWriter = response.getWriter();
	printWriter.println(jsonString);
	\end{verbatim}
	
\end{latin}			
		
		قطعه کد زیر مربوط به زمانی است که مکان کاربر یافت نشده است:‌
	\begin{latin}
		\begin{verbatim}
	StoreResponse storeResponse = new 
	StoreResponse(510,"The store could not be detected",0,null);
	Gson gson = new Gson();
	String jsonString = gson.toJson(storeResponse,StoreResponse.class);
	PrintWriter printWriter = response.getWriter();
	printWriter.println(jsonString);
		\end{verbatim}
		
	\end{latin}		
	
	\section{{\large\lr{Hibernate}}}
	{\normalsize \lr{‌Hibernate}}
	یک راه‌حل 
	{\normalsize \lr{‌Object-Relational Mapping (ORM)}}
	برای پلتفورم 
	{\normalsize \lr{‌Java}} 
	است،  که بصورت یک قالب کاری متن‌باز 
	\LTRfootnote{Open Source}
	توسط 
	{\normalsize \lr{‌Gavin King}} 
	در سال ۲۰۰۱ بوجود آمد. 
	{\normalsize \lr{‌Hibernate}} 
	یک سرویس پرس‌وجوی قدرتمند و با عملکرد بالا برای نرم‌افزارهای 
	{\normalsize \lr{‌Java}} 
	می‌باشد
		\cite{hibernate}
	. 
	
{\normalsize \lr{‌Hibernate}} 
کلاس‌های 
{\normalsize \lr{‌Java}}
را به جداول 
{\normalsize \lr{‌SQL}} 
نگاشت می‌کند و 
بین اشیاء مرسوم
{\normalsize \lr{‌Java}} 
	و سرور پایگاه‌داده قرار دارد و وظیفه‌ی ذخیره‌ی اشیاء را بر روی مکانیزم‌ها و الگوهای  
	{\normalsize \lr{‌O/R}} 
	دارد. 
	در شکل 
	\ref{fig:orm} 
	ساختار 
		{\normalsize \lr{‌O/R}} 
	نشان داده شده است.
	
	\begin{figure}[h]
		\centering
		\includegraphics[height=4cm]{images/orm}
		\caption{{\footnotesize \lr{‌ORM/Hibernate}} }
		\label{fig:orm}
	\end{figure}
	 
\subsection{اجزاری برنامه‌نویسی {\normalsize \lr{‌Hibernate}} }
	\subsubsection{شیء {\small \lr{‌Configuration}} }
اولین شیءای که در هر نرم‌افزار بر اساس 
{\normalsize \lr{‌Hibernate}} 
و تنها یک با هم ساخته می‌شود، شیء 
{\normalsize \lr{‌Configuration}} 
می‌باشد.  این شیء نشان دهنده‌ی تنظیمات و یا فایل‌های خصوصیات می‌باشد. شیء
{\normalsize \lr{‌Configuration}} 
دو جزء اصلی را فراهم می‌کند:
\begin{itemize}
	\item[-]
	\textbf{{\small \lr{‌Database Connection}} : }
		 توسط یک یا چند فایل تنظیمات پشتیبانی شده توسط
{\normalsize \lr{‌Hibernate}} 
		 	انجام می‌شود.
		 	این فایل ها
		 	{\normalsize \lr{‌hibernate.properties}} 
		 	و
		 	{\normalsize \lr{‌hibernate.cfg.xml}} 
		 	هستند.
	\item[-]
		\textbf{{\small \lr{‌Class Mapping Setup}} : }
این جزء اتصال بین کلاس‌های 
{\normalsize \lr{‌Java}} 
و جداول پایگاه داده را ایجاد می‌کند.
\end{itemize}
 
		\subsubsection{شیء {\small \lr{‌SessionFactory}} }
از شیء 
{\normalsize \lr{‌Configuration}} 
برای ساخت  شیء
{\normalsize \lr{‌SessionFactory}} 
استفاده می‌شود.  شیء
{\normalsize \lr{‌SessionFactory}} 
به اصطلاح یک شیء سبک وزن می‌باشد و در زمان شروع برنامه به منظور استفاده‌ی مجدد از آن، ساخته می‌شود. برای هر پایگاه داده نیازمند یک 
{\normalsize \lr{‌SessionFactory}} 
جدا خواهیم بود. 
		\subsubsection{شیء {\small \lr{‌Session}} }
یک 
{\normalsize \lr{‌Session}} 
برای ایجاد یک ارتباط فیزیکی با پایگاه داده مورد استفاده قرار می‌گیرد. شیء
{\normalsize \lr{‌Session}}
 به اصطلاح شیء سبک می‌باشد که در هر تعامل با پایگاه داده باید ساخته شود. 
			\subsubsection{شیء {\small \lr{‌Transaction}} }
	یک 
	{\normalsize \lr{‌Transaction}}
	نشان‌دهنده‌ی یک واحد کاری با پایگاه‌داده می‌باشد و بیشتر 
	{\normalsize \lr{‌RDBMS}}
	ها از قابلیت 
	{\normalsize \lr{‌Transaction}}
	پشتیبانی می‌کنند. 
	
			\subsubsection{شیء {\small \lr{‌Query}} }	
	شیء 
		{\normalsize \lr{‌Query}}
از رشته‌ی 
{\normalsize \lr{‌SQL}}
و یا
{\normalsize \lr{‌HQL}}
برای نسبت دادن داده‌ها و ساختن آن‌ها استفاده می‌کنند.  
	
				\subsubsection{شیء {\small \lr{‌Criteria}} }	
	شیء
			{\normalsize \lr{‌Criteria}}
	برای ساخت و اجرای پرس‌وجو‌ها در محیط شیءگرایی و واکاوی اشیاء به کار می‌روند.		
			
	\subsection{ {\normalsize \lr{‌hibernate.cfg.xml }} }
	{\normalsize \lr{‌Hibernate}}
	نیازمند آن است  قبل از اینکه از آن استفاده شود، اطلاعات نگاشت به منظور تعریف چگونگی ربط کلاس‌ها به جداول پایگاه داده را بداند. همچنین 
	{\normalsize \lr{‌Hibernate}}
	نیازمند است اطلاعات اتصال به پایگاه داده و پارامترهای مربوطه به آن داده شود. این اطلاعات در فایلی به نام
	{\normalsize \lr{hibernate.properties}}
	و یا
	{\normalsize \lr{‌hibernate.cfg.xml}}
	در فرمت 
	{\normalsize \lr{‌XML}}
	آورده می‌شوند.  همچنین در این فایل اسم‌کاربری و کلمه‌ی عبور مربوط به پایگاه داده نیز وارد می‌شود.
	\noindent
	نمونه‌ای از فایل تنظیمات برای پایگاه داده‌ای به نشانی 
		{\normalsize \lr{‌jdbc:m ysql://localhost/test}}
و	فایل حاوی نگاشت کلاس 
			{\normalsize \lr{‌BeaconEntity}}
	به شکل زیر می‌باشد:‌
	\begin{latin}
		\begin{verbatim}
		<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE hibernate-configuration SYSTEM
 "http://www.hibernate.org/
 dtd/hibernate-configuration-3.0.dtd">
<hibernate-configuration> <session-factory>
<property name="hibernate.dialect">
org.hibernate.dialect.MySQLDialect
</property>
<property name="hibernate.connection.driver_class">
com .m ysql.jdbc.Driver
</property>
<!-- Assume test is the database name -->
<property name="hibernate.connection.url">
 jdbc:m ysql://localhost/test
</property>
<property name="hibernate.connection.username">
root
</property>
<property name="hibernate.connection.password">
root123
</property>
<!-- List of XML mapping files -->
<mapping resource="BeaconEntity.hbm.xml"/>
</session-factory> 
</hibernate-configuration>
		\end{verbatim}
		
	\end{latin}	

	\subsection{ کلاس{\normalsize \lr{‌POJO }} }
	یک کلاس 
				{\normalsize \lr{‌POJO}}
		\LTRfootnote{Plain Old Java Object}
		یک کلاس 
						{\normalsize \lr{‌Java}}
	است که از هیچ کلاس دیگری به ارث نمی‌برد و یا رابط 
			\LTRfootnote{Interface}
	دیگری را پیاده سازی نکرده است.	همه‌ی اشیاء عادی 			
							{\normalsize \lr{‌Java}}	
	به صورت 
							{\normalsize \lr{‌POJO}}
							هستند. این کلاس‌ها در اصل منطبق با کلاس‌های 
													{\normalsize \lr{‌JavaBeans}}
				و باید به فرمت آن‌ها باشند. 
				
			
			\noindent
			به عنوان مثال کلاس 
									{\normalsize \lr{‌BeaconEntity.java}}
									زیر به شکل 
															{\normalsize \lr{‌POJO}}
															و 
																					{\normalsize \lr{‌JavaBeans}} 
																					می‌باشد:
		\begin{latin}
		\begin{verbatim}
public class BeaconEntity {
private int idbeacon;
private String name;
private String uuid;
private Integer major;
private Integer minor;
private Integer idstore;

public BeaconEntity(int idbeacon, String name, String uuid, Integer major, Integer minor, Integer idstore) {
this.idbeacon = idbeacon;
this.name = name;
this.uuid = uuid;
this.major = major;
this.minor = minor;
this.idstore = idstore;
}

public int getIdbeacon() {return idbeacon;}
public void setIdbeacon(int idbeacon) {this.idbeacon = idbeacon;}
public String getName() {return name;}
public void setName(String name) {this.name = name;}
public String getUuid() {return uuid;}
public void setUuid(String uuid) {this.uuid = uuid;}
public Integer getMajor() {return major;}
public void setMajor(Integer major) {this.major = major;}
public Integer getMinor() {return minor;}
public void setMinor(Integer minor) {this.minor = minor;}
public Integer getIdstore() {return idstore;}
public void setIdstore(Integer idstore) {this.idstore = idstore;}
}

		\end{verbatim}
		
	\end{latin}	
	
		\subsection{ فایل{\normalsize \lr{‌Mapping configuration }} }	
		با استفاده از فایل 
									{\normalsize \lr{‌‌Mapping configuration}}
	کلاس‌های تعریف شده به جداول پایگاه داده نگاشت می‌شوند. 
	نمونه‌ای از یک فایل نگاشت:
		\begin{latin}
		\begin{verbatim}
		<?xml version='1.0' encoding='utf-8'?>
		<!DOCTYPE hibernate-mapping PUBLIC
		"-//Hibernate/Hibernate Mapping DTD 3.0//EN"
		"http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd">
		<hibernate-mapping>
		
		<class name="mypaydbmap.BeaconEntity" table="beacon" schema="mypay">
		<id name="idbeacon">
		<column name="idbeacon" sql-type="int(11)"/>
		</id>
		<property name="name">
		<column name="name" sql-type="varchar(45)" length="45"/>
		</property>
		<property name="uuid">
		<column name="uuid" sql-type="varchar(200)" length="200"/>
		</property>
		<property name="major">
		<column name="major" sql-type="int(11)" not-null="true"/>
		</property>
		<property name="minor">
		<column name="minor" sql-type="int(11)" not-null="true"/>
		</property>
		<property name="idstore">
		<column name="idstore" sql-type="int(11)" not-null="true"/>
		</property>
		</class>
		</hibernate-mapping>
		\end{verbatim}
		
	\end{latin}											
		
	 \subsection{نحوه‌ی استفاده}	
	پس از ساخت فایل تنظیمات ، کلاس‌های 
	{\normalsize \lr{‌POJO}}، فایل نگاشت و آماده کردن جداول پایگاه داده برای اتصال به آن‌ها، 
	{\normalsize \lr{‌‌Hibernate}}
	 آماده برای انجام فعالیت‌های مربوط به پایگاه‌داده می‌باشد. 
	 به عنوان مثال برای اضافه کردن یک حساب کاربری برای کاربر به شکل زیر توسط تابع 
	 	{\normalsize \lr{‌addUser()}}
	 انجام می‌شود: 
	\begin{latin}
	\begin{verbatim}
	public Integer addUser(String username,String password,String 
	type,String phone,String email,Integer age){
	try{
   SessionFactory sessionFactory = new
  Configuration().configure().buildSessionFactory(); 
  }catch (Throwable ex) {
   System.err.println("Failed to create sessionFactory object."
    + ex); throw new 
	  ExceptionInInitializerError(ex);
	}
	
	Session session = sessionFactory.openSession();
	Transaction tx;
	Integer id = null;
	try {
	tx = session.beginTransaction();
	UserEntity userEntity = new
	 UserEntity(username,password,type,age,phone,email,(byte)1);
	id = (Integer)session.save(userEntity);
	tx.commit();
	  }catch (Exception e){
	System.err.println(e);
      	}
	finally {
	session.close();
	}
	return id;
	}
	\end{verbatim}
	
\end{latin}		 
	 

	
		
		%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		\chapter{طراحی و پیاده‌سازی نرم‌افزار پرداخت سمت کلاینت}\label{clientimplementation}
در این فصل ابتدا به توضیح تکنولوژی‌های استفاده شده و سپس به نحوه‌ی عملکرد،  پیاده‌سازی و چگونگی استفاده نرم‌افزار از تکنولوژی‌ها بررسی خواهد شد.

\section{{\normalsize \lr{Beacon}}}
         {\normalsize \lr{‌Beacon}} 
یک دستگاه ساتع کننده‌ی سیگنال رادیویی 
         {\normalsize \lr{‌Bluetooth}} 
         است.
به بیان ساده 
         {\normalsize \lr{‌Beacon}} 
         عملکردی شبیه به فانوس دریایی دارد: 
        بطور پشت‌سرهم سیگانال‌هایی یکسان را ارسال می‌کند که از طریق دستگاه‌های دیگر قابل مشاهده است. 
       اگرچه به جای نور مرئی، سیگنال‌های رادیویی که از ترکیبی از اعداد و حروف تشکیل شده‌اند که در فواصل زمانی معین تقریبا یک دهم ثانیه،  سیگنال‌ها را مخابره می‌کند. دستگاهی که دارای تکنولوژی 
                {\normalsize \lr{‌Bluetooth v4.0}} 
    یا 
                        {\normalsize \lr{‌BLE}} \LTRfootnote{Bluetooth Low Energy}
      باشد، مانند تلفن‌های همراه هوشمند، می‌تواند سیگنال‌های 
               {\normalsize \lr{‌Beacon}} 
   را دریافت کند، همانند دریانوردی که چراغ فانوس دریایی را می‌بیند و از مکان خود مطلع می‌شود. 
   
 \subsection{ساختار داخلی {\small \lr{Beacon}}}
		{\normalsize \lr{Beacon}}ها 
		دستگاه‌های بسیار کوچک و ساده‌ای به لحاظ الکترونیکی هستند. آن‌ها متشکل از یک پردازنده، رادیو، و باتری‌ها می‌باشند.  
		{\normalsize \lr{Beacon}}ها 
		اغلب از باتری‌های کوچک لیتیومی 
		       	\LTRfootnote{lithium}
 که مقدار انرژی بیشتری دارند و کوچتر از باتری‌های نوع 
                {\normalsize \lr{‌AA}} 
 هستند و یا از راه درگاه‌های 
                {\normalsize \lr{‌USB}} 
 انرژی مورد نیاز خود را بدست می‌آورند. 

در شکل 
\ref{fig:estimote-beacons}
نمونه‌ای از دستگاه
{\normalsize \lr{‌Beacon}} 
تولید‌شده‌ی شرکت
{\normalsize \lr{‌Estimote}} 
نشان‌داده شده است.

\begin{figure}[h]
	\label{beacon}
	\centering
	\includegraphics[height=5cm]{images/estimote-beacons}
	\caption{{\footnotesize \lr{‌Estimote Beacon}} }
	\label{fig:estimote-beacons}
\end{figure}


 
 \subsection{موارد استفاده}
 
 از 
                {\normalsize \lr{‌Beacon}} 
                می‌توان  در، خرده‌فروشی 
		       	\LTRfootnote{Retail}
                ،  آموزش، فرهنگ، فرودگاه‌ها، رویدادها، بیمارستان‌ها و اداره‌ها  استفاده کرد. از موضوعات بروز و جدید،  به مسائل  
                               {\normalsize \lr{‌IoT}} 
                               		       	\LTRfootnote{Internet of Things}
            و    بازاریابی مجاورتی
		       	\LTRfootnote{Proximity Marketing}
                می‌توان اشاره کرد‌.
            در این پایان‌نامه    موضوعات کاربردهای تجاری و  مورد‌های تجاری 
                {\normalsize \lr{‌Beacon}} 
                مورد بحث نخواهد بود.
                
   \subsection{پروتکل‌ها}
		
		پروتکل‌هایی به منظور ارتباط با 
		{\normalsize \lr{‌Beacon}} ها
		وجود دارد که معروف‌ترین آن‌ها 
		{\normalsize \lr{‌iBeacon}} 
		و
		{\normalsize \lr{‌Eddystone}}                    
		می‌باشند. در ادامه به توضیح این دو پروتکل پرداخته خواهد شد.  تمرکز بیشتر بر روی پروتکل 
				{\normalsize \lr{‌iBeacon}} 
				خواهد بود.
	\subsubsection{{\small \lr{iBeacon }} }
	پروتکل
			{\normalsize \lr{‌iBeacon}} 
اولین و پر استفاده‌ترین پروتکل ارتباطی حال حاضر است. این پروتکل توسط 
		{\normalsize \lr{‌Apple}} 
		توسعه یافته است و توسط 
				{\normalsize \lr{‌iOS}} 
نیز پشتیبانی می‌شود. اگر چه این پروتکل تحت دیگر پلتفورم‌ها و سیستم‌عامل‌ها کار می‌کند، اما بهترین عملکرد را با دستگاه‌های 
		{\normalsize \lr{‌iPhone}} 
		و 
				{\normalsize \lr{‌iPad}} 
				دارد. 				در شکل 
				\ref{fig:ibeacon}
آیکون این تکنولوژی نشان داده شده است.
	\begin{figure}[h]
		\centering
		\includegraphics[height=1.5cm]{images/iBeacon}
		\caption{{\small \lr{‌iBeacon icon}} }
		\label{fig:ibeacon}
	\end{figure}
	
	
		
	\subsubsection{{\small \lr{Eddystone }} }	
پروتکل 
		{\normalsize \lr{‌Eddystone}} 
 دارای فرمتی جدید و پروتکل ارتباطی باز است که توسط 
 		{\normalsize \lr{‌Google}} 
 		توسعه یافته است. 
	
		بیشتر عملکرد 
				{\normalsize \lr{‌Eddystone}} 
				مشابه 
						{\normalsize \lr{‌iBeacon}} 
						می‌باشد اما دارای قابلیت های توسعه یافته‌ی بیشتری می‌باشد. 
		شکل 
	\ref{fig:eddystone2}
	آیکون این تکنولوژی را نشان می‌دهد.
						\begin{figure}[h]
							\centering
							\includegraphics[height=2.5cm]{images/eddystone2}
							\caption{{\small \lr{‌Eddystone icon}} }
							\label{fig:eddystone2}
						\end{figure}
			{\normalsize \lr{‌Eddystone}} 
			دارای سه نوع مختلف است: 
	\begin{itemize}
		\item[-] 				{\normalsize \lr{‌Eddystone-UID}} 
		\item[-] 				{\normalsize \lr{‌Eddystone-URL}} 
		\item[-] 				{\normalsize \lr{‌Eddystone-TLM}} 
	\end{itemize}
	{\normalsize \lr{‌Eddystone-UID}} 
	کارایی همانند 
	 		{\normalsize \lr{‌iBeacon}} 
	 		دارد: انتشار قطعه کدی به فواصل زمانی یکسان. 
		{\normalsize \lr{‌Eddystone-URL}}
		یک 
			{\normalsize \lr{‌URL}} 
			که توسط هرکسی با یک گوشی هوشمند   (خواه نرم‌افزار شمارا نصب کرده باشند یا نه) قابل مشاهده است. 
			{\normalsize \lr{Eddystone-TLM}}
داده‌های مربوط به فاصله سنجی را انتشار می‌دهند
\cite{kontakt}.

\subsection{ تکنولوژی    {\normalsize \lr{‌iBeacon}} }
این تکنولوژی با عرضه‌ی 
	 		{\normalsize \lr{‌iOS 7}} 
معرفی شد و امکانات جدیدی در زمینه‌ی مکان‌یابی و آگاهی از مکان ارائه کرد. با استفاده از تکنولوژی 
	 		{\normalsize \lr{‌Bluetooth Low Energy (BLE)}} 
یک دستگاه دارای تکنولوژی
	 		{\normalsize \lr{‌iBeacon}}
	می‌تواند ناحیه‌ای اطراف یک شیء را مقرر کند تا زمانی که دستگاه 
		 		{\normalsize \lr{‌iOS}}
	از آن خارج شد و یا به آن وارد شد و فاصله‌ی تقریبی آن را تعیین کند. 
	
	 \subsection{دستگاه‌های دارای تکنولوژی    {\normalsize \lr{‌iBeacon}} } 
دستگاه‌هایی با تکنولوژی 
	 		{\normalsize \lr{‌iBeacon}}
	 		می‌توانند برای تأمین انرژی از باتری‌های سلولی برای ماه‌ها و یا بیشتر استفاده کنند. دستگاه‌های 
	 			 		{\normalsize \lr{‌iOS}} 
	 			 		نیز می‌توانند اعلان‌های 
	 			 			 		{\normalsize \lr{‌iBeacon}}
	 			 			 		را انتشار دهند، اگر چه این قابلیت برای ناحیه‌ی محدودی می‌تواند باشد. 
	 			 			 		
	\subsection{سیگنال‌های {\normalsize \lr{‌iBeacon}}} 			 			 		
	اطلاعاتی که در اعلان‌های سینگال 
		 		{\normalsize \lr{‌iBeacon}}
		 		می‌باشد به شرح زیر هستند:  			 			 		
	\begin{itemize}
		\item[-] 	{\normalsize \lr{‌UUID}}
		\item[-] 	{\normalsize \lr{‌Major}}
		\item[-]	{\normalsize \lr{‌Minor}}
	\end{itemize}
 این سه مقدار اطلاعات شناسایی را برای 
 		 		{\normalsize \lr{‌iBeacon}}
 		 		فراهم می‌کنند.  توسعه دهندگان نرم‌افزار از 
 		 				 		{\normalsize \lr{‌UUID}}،  به منظور تعریف یک شناسنده برای نرم‌افزار خود یا مورد کاربردی خود استفاده می‌کنند. 
از دو مقادیر 
		 		{\normalsize \lr{‌Major}}
		 		و 
		 				 		{\normalsize \lr{‌Minor}}
		 				 		هم برای تقسیم بندی‌های بیشتر استفاده می‌شود. برای مثال نرم‌افزار خرده‌فروشی  با شعب موجود در سراسر کشور را در نظر بگیرید که از این تکنولوژی استفاده کرده باشد. مقدار 
		 				 		{\normalsize \lr{‌UUID}}
یک مقدار ثابتی برای کل نرم‌افزار خواهد بود، و توسط تمامی مکان‌ها به اشتراک گذاشته می‌شود. این مقدار به دستگاه 
{\normalsize \lr{‌iOS}}
امکان این را می‌دهد که با یک شناساگر، مناطق مربوط به این فروشگاه را تشخیص بدهد. از مقدار 
{\normalsize \lr{‌Major }}
برای تقسیم بندی شهر‌ها استفاده می‌شود، به این شکل که هر شهر مختلف دارای یک شماره‌ی 
{\normalsize \lr{‌Major}}
خاص خود است. برای مثال شهر تهران مقدار ۱،  شهر اصفهان ۲ و به همین ترتیب برای شهر‌های دیگر. از مقدار 
{\normalsize \lr{‌Minor}}
به منظور بخش‌بندی درون فروشگاه استفاده می‌شود، برای مثال بخش حسابداری مقدار ۱۰، بخش لوازم‌خانگی مقدار ۲۰ و بخش پوشاک مقدار ۳۰. بدین ترتیب دستگاه 
{\normalsize \lr{‌iOS}}
با استفاده از این مقادیر می‌تواند از مکان حال حاضر خود مطلع شود.	هیچ یک ازین مقادیر توسط 
{\normalsize \lr{‌Apple}}
ثبت نخواهند شد.				

{\normalsize \lr{‌iBeacon}}
متکی به تکنولوژی 
{\normalsize \lr{‌ BLE}} 
می‌باشد، از این رو نیازمند مدل‌های بالاتر از
{\normalsize \lr{‌iPhone 4S}}،
{\normalsize \lr{‌iPod}} 
نسل۵ و 
{\normalsize \lr{‌iPad}} 
نسل ۳ به بالا
یا 
{\normalsize \lr{‌iPad mini}}
می‌توانند از این تکنولوژی استفاده کنند.

\subsection{رابط‌های نرم‌افزاری {\normalsize \lr{‌iBeacon}}}
ماقبل 
{\normalsize \lr{‌iOS 7}}
از واسط کاربری 
{\normalsize \lr{‌Core Location}}
برای تعریف مناطق جغرافیایی 
		       	\LTRfootnote{geofence}
	استفاده می‌شد  (استفاده از طول و عرض جغرافیایی و شعاع).
			       	\LTRfootnote{Proximity Marketing}
	{\normalsize \lr{‌iBeacon}}
	قابلیتی اضافه‌تر با تعریف شناسنده برای منطقه بیان کرد. 
	\subsubsection{ حریم‌خصوصی  }
	به این علت که 
	{\normalsize \lr{‌iBeacon}}
	بخشی از 
	{\normalsize \lr{‌Core Location}}
	می‌باشد، اجازه‌ی کاربر یکسانی برای استفاده از این سرویس مورد نیاز خواهد بود. زمانی که نرم‌افزاری تلاش برای استفاده از 
	{\normalsize \lr{‌iBeacon}}
	می‌کند، کاربر هشدار اجازه‌ی یکسانی با 
	{\normalsize \lr{‌Core Location}}
	خواهد دید. 
	
\subsubsection{دقت {\small \lr{‌iBeacon}}}
برای اطمینان حاصل کردن از یک تجربه‌ی خوب برای کاربر،  بررسی چگونگی تشخیص سیگنال‌ها توسط 
{\normalsize \lr{‌iBeacon}} ها 
و دقت آن‌ها مورد اهمیت است. زمانی که یک دستگاه 
{\normalsize \lr{‌iOS}}
یک سیگنال 
{\normalsize \lr{‌Beacon}}
را دریافت می‌کند،   دستگاه از قوت سیگنال برای تعیین دقت و اندازه‌گیری مجاورت با آن استفاده می‌کند. هرچقدر که سیگنال قوی تر باشد 
{\normalsize \lr{‌iOS}}
می‌تواند با اطمینان بیشتری مقدار مجاورت را تشخیص دهد. 

دو سرویس اصلی که 
{\normalsize \lr{‌iBeacon}}
 ارائه می‌دهد  و در پیاده‌سازی مورد استفاده قرار گرفته است،
  {\normalsize \lr{‌Monitoring}} 
 و
  {\normalsize \lr{‌Ranging}}
  می‌باشد که در ادامه به توضیح این دو سرویس پرداخته می‌شود.

\subsection{{\normalsize \lr{‌Monitoring}}}
همانند 
{\normalsize \lr{‌Monitoring}} 
منطقه و یا نظارت کردن منطقه در تکنولوژی موجود جغرافیایی، یک نرم‌افزار می‌تواند ورود و خروج از یک منطقه را به کاربر اطلاع دهد. زمانی که یک نرم‌افزار درخواست برای نظارت یک منطقه را می‌دهد،  حتما باید 
{\normalsize \lr{‌UUID}}
منطقه‌ی مورد نظر را ارائه دهد. در حالی که نظارت مناطق برای یک دستگاه محدود به ۲۰ 
{\normalsize \lr{‌UUID}}
مختلف می‌باشد،  دستگاه می‌تواند چندین مکان فیزیکی را تحت نظارت قرار دهد. برای مثال یک دستگاه می‌تواند با استفاده از تنها یک 
{\normalsize \lr{‌UUID}}
چندین مکان مختلف را تحت نظارت قرار دهد. روش تحت نظارت قرار دادن با 
{\normalsize \lr{‌iBeacon}}
نسبت به روش جغرافیایی فرق دارد.  بدین شکل که در روش 
{\normalsize \lr{‌iBeacon}}
تنها با یک خط کد می‌توان چندین مکان و یا شیء را تحت نظارت قرار داد. 

همانطور که قبلا هم گفته شد از مقادیر 
{\normalsize \lr{‌Major}}
 و 
{\normalsize \lr{‌Minor}}
نیز می‌توان برای تقسیم بندی‌های بیشتر استفاده کرد. برای شروع زیر نظر قرار دادن یک منطقه ، این دو مقدار ضروری نخواهند بود. 

همانند  نظارت با استفاده از مکان جغرافیایی، زمانی که کاربر از منطقه‌ خارج و یا وارد می‌شود ، نرم‌افزار مطلع خواهد شد. اگر نرم‌افزار بسته شده باشد، و در حال کار نباشد ، آگهی‌ها 
		       	\LTRfootnote{Notification}
		       	به صورت پشت‌پرده 
		       			       	\LTRfootnote{Background}
		       	به نرم‌افزار تحویل داده می‌شوند.  یکی از ملاحضات مهم در 
{\normalsize \lr{‌iOS 7}}
در مورد این مسأله به این شکل است که اگر کاربر به صراحت اجازه به فعالیت سرویس 
{\normalsize \lr{‌Background App Refresh}}
را ندهد، نرم‌افزار دیگر اعلان‌ها را دریافت نخواهد کرد.  با این وجود استفاده از سرویس
{\normalsize \lr{‌Ranging}}
را می‌تواند ادامه دهد.

 بر اساس 
 {\normalsize \lr{‌BLE}}
 محدوده‌ی تحت پوشش سیگنال‌ها به ده‌ها متر می‌رسد، که از نظارت با استفاده از جغرافیا دقیق‌تر می‌باشد.
 در حقیقت موارد استفاده‌ی مکان‌یابی جغرافیایی،  در مکان‌های سرباز می‌باشد، در صورتی که مورد استفاده‌ی 
 {\normalsize \lr{‌iBeacon}}
 برای مکان‌های سربسته می‌باشد. با این وجود دقت در سیگنال‌های 
 {\normalsize \lr{‌iBeacon}}
 می‌تواند بر اساس موانع فیزیکی متغیر باشد. 
  		       	
 \subsection{{\normalsize \lr{‌Ranging}}}
  {\normalsize \lr{‌iOS 7}}
  مجموعه‌ای جدید برای تعیین مقدار تقریبی مجاورت نسبت به یک دستگاه با استفاده از تکنولوژی 
   {\normalsize \lr{‌iBeacon}}
   معرفی کرد، که اسم این فرآیند 
    {\normalsize \lr{‌Ranging}}
    و یا محدوده‌یابی می‌باشد. 
    بر اساس سناریو‌های متداول،
     {\normalsize \lr{‌iOS}}
       فیلترهایی برای حدس میزان مجاورت نیز معرفی کرده است. این حدس‌های مجاورت به چهار وضعیت زیر تعریف می‌شوند:‌
     \begin{itemize}
     	\item[-]  {\normalsize \lr{‌Immediate}:}
     	بالاترین حالت اطمینان است که نشان می‌دهد دستگاه بسیار به 
     	 {\normalsize \lr{‌Beacon}}
     	 نزدیک می‌باشد.
     	\item[-]  {\normalsize \lr{‌Near }:}
   دستگاه با یک دیدی واضح نسبت به 
    {\normalsize \lr{‌Beacon}}
    قرار دارد، فاصله‌ی مجاورت حدودا ۱ تا ۳ متر است.  
     	\item[-] {\normalsize \lr{‌Far}:}
     	این وضعیت نشان می‌دهد که یک دستگاه
     	 {\normalsize \lr{‌Beacon}}
     	 قابل تشخیص است،  اما اطمینان در دقت برای تعیین نزدیکی آن خیلی کم است. نکته‌ی مهم در این جا این است که این وضعیت نشان نمی‌دهد که دستگاه از لحاظ فیزیکی به 
     	  {\normalsize \lr{‌iBeacon}}
     	  نزدیک نمی‌باشد.  
     	\item[-] {\normalsize \lr{‌Unknown}:}
     	مجاورت نسبت به 
     	 {\normalsize \lr{‌Beacon}}
     	 قابل تشخیص نیست. این وضعیت ممکن است نشان دهنده‌ی این امر باشد که محدوده‌یابی شروع شده است، اما معیارها برای تشخیص مقدار مجاورت کافی نیستند. 
     \end{itemize}
    
    \subsection{محدودیت‌های فیزیکی}
  همانطور که قبلا اشاره شد  دستگاه‌های 
         	  {\normalsize \lr{‌iBeacon}}
         	  برای انتشار سیگنال‌ها از تکنولوژی
         	       	  {\normalsize \lr{‌BLE}}
     استفاده می‌کنند. 
          	  {\normalsize \lr{‌BLE}}
     از فرکانس 
          	  {\normalsize \lr{‌2.4 Hz}}
          	   استفاده می‌کند، بهمین علت توسط موانع فیزیکی همچون دیوار، در یا دیگر ساختار‌های فیزیکی تحت‌تأثیر اثر میرایی یا تضعیف قرار می‌گیرد. فرکانس 
          	        	  {\normalsize \lr{‌2.4 Hz}} 
  همچنان می‌تواند در معرض آب قرار بگیرد، بنابراین بدن انسان نیز بر ضعف سیگنال‌ها تأثیر خواهند گذاشت. 
  اطلاع از موانع موجود برای سیگنال‌‌ها بدین دلیل مهم است که، این موانع بر روی قدرت سیگنال تأثیر مستقیم می‌گذارند،   بنابراین دستگاه 
       	  {\normalsize \lr{‌iOS}}
       	  سیگنال‌های ضعیف‌تری را برای تشخیص مجاورت دریافت می‌کنند  	        	     	       	  
\cite{ibeacover}.
   
\section{برنامه‌نویسی در {\normalsize \lr{‌iOS}}}
	برای برنامه نویسی در محیط 
	{\normalsize \lr{‌iOS}}
	، می‌توان از زبان‌های برنامه‌نویسی
	{\normalsize \lr{‌Objective-C}}
	و 
	{\normalsize \lr{‌Swift}}
	استفاده کرد. در این پروژه از زبان 
	{\normalsize \lr{‌Swift}}
	برای برنامه‌نویسی در محیط 
	{\normalsize \lr{‌iOS}}
	استفاده‌شده است. 
\section{ اجزای اصلی}
	\subsection{{\small \lr{‌AppDelegate.swift}}}
این کلاس دارای دو وظیفه‌ی اصلی می‌باشد: 
\begin{itemize}
	\item[-]
	کلاس 
	{\normalsize \lr{‌AppDelegate}}
	یک پنجره برای نرم‌افزار ایجاد می‌کند که در آن محتویات نرم‌افزار رسم می‌شود و انتقال بین صفحه‌های مختلف صورت می‌گیرد.
	\item[-]
	کلاس 
	{\normalsize \lr{‌AppDelegate}}
	یک نقطه‌ی شروع 
		       	\LTRfootnote{Entry Point}
	و یک حلقه‌ی اجرا 
		       	\LTRfootnote{Run Loop}
	که رویداد‌های ورودی 
			       	\LTRfootnote{Input Event}
	به ‌آن تحویل داده می‌شوند، را می‌سازد.  این کار توسط صفت 
			       	\LTRfootnote{Attribute}
	{\normalsize \lr{‌@UIApplicationMain}}	
	انجام می‌شود.
\end{itemize}
	
\subsection{	{\small \lr{‌@UIApplicationMain}}	}
استفاده از صفت 
	{\normalsize \lr{‌@UIApplicationMain}}	
	معادل با فراخوانی تابع 
		{\normalsize \lr{‌UIApplicationMain}}		
		به عنوان تعیین اسم کلاس
			{\normalsize \lr{‌AppDelegate}}	
			به عنوان اسم کلاس نماینده 
				       	\LTRfootnote{Delegate Class}		
			می‌باشد.  در جواب سیستم یک شی‌ء نرم‌افزار
						       	\LTRfootnote{Application Object}
			 تشکیل می‌دهد. شیء نرم‌افزار مسئول مدیریت چرخه‌ی حیات 
			 			       	\LTRfootnote{Life Cycle}
	نرم‌افزار می‌باشد. سیستم همچنین موردی از کلاس
			{\normalsize \lr{‌AppDelegate}}	
می‌سازد و آن‌ را به شیء نرم‌افزار مقرر می‌کند. در نهایت سیستم نرم‌افزار را اجرا می‌کند. 

کلاس
			{\normalsize \lr{‌AppDelegate}}	
	همچنین حاوی پیاده‌سازی توابع نماینده نیز می‌باشد:
\begin{latin}
	\begin{verbatim}
func application(_ application: UIApplication, 
didFinishLaunchingWithOptions launchOptions:
 [UIApplicationLaunchOptionsKey: Any]?) -> Bool
func applicationWillResignActive(_ application: UIApplication)
func applicationDidEnterBackground(_ application: UIApplication)
func applicationWillEnterForeground(_ application: UIApplication)
func applicationDidBecomeActive(_ application: UIApplication)
func applicationWillTerminate(_ application: UIApplication)
	\end{verbatim}
	
\end{latin}	
این توابع اجازه‌ی برقراری ارتباط با نماینده‌ی نرم‌افزار را فراهم می‌کنند. برای مثال در حین فرآیند انتقال از یک صفحه به صفحه‌ی دیگر و یا انتقال نرم‌افزار از 
			{\normalsize \lr{‌Background}}	
			به 
						{\normalsize \lr{‌Foreground}}
و یا بستن نرم‌افزار، شیء نرم‌افزار تابع نماینده‌ی مربوطه را فراخوانی می‌‌کند، و پاسخی که از قبل تعیین شده برای آن را اجرا می‌کند.	فراخوانی صحیح این توابع به عهده‌ی سیستم می‌باشد و برنامه‌نویس نیاز به انجام کاری نمی‌باشد. 					
هریک از توابع نماینده یک رفتار پیش‌فرض را دارا هستند. اگر پیاده‌سازی برای این توابع در نظر گرفته نشود، رفتار پیش‌فرض به اجرا در خواهد آمد. 
\subsection{	{\small \lr{‌Storyboard}}}
{\normalsize \lr{‌Storyboard}}
یک نمایش بصری از رابط کاربری نرم‌افزار می‌باشد، که صفحات مختلف، محتوی و انتقال بین صفحات را نمایش می‌دهد. 
برنامه‌نویس می‌تواند از این راه تغییرات بر رابط کاربری نرم‌افزار را ایجاد کند و نتایج را همان لحظه مشاهده کند.  	
\section{الگوی طراحی {\small \lr{‌MVC}}}\label{mvc}
همانند بسیاری از پلتفورم‌های نرم‌افزاری که از الگوی طراحی
						       	\LTRfootnote{Design Pattern}
{\normalsize \lr{‌MVC}}
استفاده می‌کنند، در برنامه‌نویسی 
{\normalsize \lr{‌iOS}}
نیز از این الگوی طراحی استفاده ‌‌شده است. الگوی 
{\normalsize \lr{‌MVC}}
شامل، 
{\normalsize \lr{‌M‌odel}}،
{\normalsize \lr{‌View}} و
{\normalsize \lr{‌Controller}}
است.  در این سبک از طراحی 
{\normalsize \lr{Controller}} 
وظیفه‌ی ارتباط بین 
{\normalsize \lr{‌View}} ها 
و مدل داده
						       	\LTRfootnote{Data Model}
را بر عهده دارد. در این طراحی 
{\normalsize \lr{Model}} ها 
وظیفه‌ی نگهداری داده‌های نرم‌افزار را بر عهده دارند و 
{\normalsize \lr{View}} ها 
  رابط کاربری را نشان می‌دهند و محتوای نمایشی نرم‌افزار را می‌سازند. با پاسخ به اقدامات کاربران و شکل دادن محتوای 
  {\normalsize \lr{View}} 
  ها از مدل داده، 
  {\normalsize \lr{Controller}} 
  ها بعنوان درگاهی میان 
  {\normalsize \lr{View}} 
  و 
  {\normalsize \lr{Model}} 
  عمل می‌کنند. 
  شکل 
  \ref{fig:mvcpattern-2}
  ارتباط بین اجزای مختلف مدل 
  {\normalsize \lr{‌MVC}}
  را نشان می‌دهد.
  
  \begin{figure}[h]
  	\centering
  	\includegraphics[height=5cm]{images/MVCPattern-2}
  	\caption{الگوی‌طراحی  {\normalsize \lr{MVC}} }
  	\label{fig:mvcpattern-2}
  \end{figure}

\subsection{{\small \lr{‌UIView}}}
عناصری که در رابط کاربری نمایش داده می‌شوند 
  {\normalsize \lr{View}} 
  نام دارند. 
    {\normalsize \lr{View}} ها 
    محتوا را به کاربر نمایش می‌دهند.
      {\normalsize \lr{View}} 
      ها رفتارهای مختلفی دارند از جمله‌ی نمایش واسط‌های کاربری و نشان‌دادن عکس‌العمل به کاربر. 
در 
  {\normalsize \lr{iOS}} 
  تمام اشیاء 
    {\normalsize \lr{View}} 
    توسط نوع 
      {\normalsize \lr{UIView}} 
       و یا زیرکلاس‌های آن ساخته می‌شوند. از 
         {\normalsize \lr{View}}  های
   پرکاربرد می‌توان به 
     {\normalsize \lr{UITextField}} 
     اشاره کرد که اجازه‌ی تایپ یک متن در یک خط را به کاربر می‌دهد.

\subsection{{\small \lr{‌UIView Controller}}}
 در 
   {\normalsize \lr{iOS}}
  نقش 
    {\normalsize \lr{Controller}} 
    را 
     {\normalsize \lr{ViewController}} ها
     بر عهده دارند. همه‌ی اشیاء 
       {\normalsize \lr{ViewController}}  
در 
  {\normalsize \lr{iOS}}
  از نوع 
      {\normalsize \lr{UIViewController}}
  و زیر کلاس‌های آن هستند. 
  برنامه‌نویس با پیاده‌سازی و شخصی‌سازی توابع 
         {\normalsize \lr{ViewController}}  
   می‌تواند رفتار 
          {\normalsize \lr{ViewController}}  
          را تغییر دهد.       
    یک شیءای از کلاس
    {\normalsize \lr{‌ViewController}}
     به همراه یک سری از توابع به منظور مدیریت سلسله مراتب 
     {\normalsize \lr{‌View}} ‌
     آن می‌باشد. 
     {\normalsize \lr{‌iOS}}
     بصورت خودکار و در زمان مناسب که 
     {\normalsize \lr{‌ViewController}} 
     در وضعیت‌های متفاوت قرار می‌گیرد،
     این توابع را فراخوانی می‌کند.  
     این مسأله که چه زمانی این توابع فراخوانی می‌شوند برای تشخیص رفتار 
     {\normalsize \lr{‌ViewController}} 
     حائز اهمیت هستند. 
     شکل 
     \ref{fig:vclifecycle}
     چرخه‌ی حیات یک 
          {\normalsize \lr{‌ViewController}} 
     و فراخوانی توابع مربوطه را نشان می‌دهد.
	\begin{figure}[h]
		\centering
		\includegraphics[height=10cm]{images/VClifecycle}
		\caption{وضعیت‌های {\footnotesize \lr{‌View Controller}} }
		\label{fig:vclifecycle}
	\end{figure}
	{\normalsize \lr{‌iOS}} 
توابع را به شکل زیر فراخوانی می‌کند: 
\begin{itemize}
	\item[ ]
	{\normalsize \lr{‌viewDidLoad()}}-
	زمانی که محتویات یک 
	{\normalsize \lr{‌View}} 
	توسط 
	{\normalsize \lr{‌ViewController}} 
	ساخته می‌شود و از 
	{\normalsize \lr{‌Storyboard}} 
	بارگذاری می‌شود، این تابع فراخوانی می‌شود. 
	
	بطورمعمول این تابع فقط یکبار توسط 
	{\normalsize \lr{‌iOS}} 
	زمانی که محتوای 
	{\normalsize \lr{‌View}} 
	ساخته می‌شود، فراخوانی می‌شود. با این وجود محتوای 
	{\normalsize \lr{‌View}}
	الزاما، بار اولی که 
	{\normalsize \lr{‌ViewController}}
	مقداردهی اولیه می‌شود،   ساخته نمی‌شود. 
	
	\item[ ]
	{\normalsize \lr{‌viewWillAppear()}}- 
	قبل از اینکه محتوای 
	{\normalsize \lr{‌View}}
	مربوط به 
	{\normalsize \lr{‌ViewController}}
	به سلسله مراتب 
	{\normalsize \lr{‌View}}
	نرم‌افزار اضافه شود، این تابع فراخوانی می‌شود. از این تابع برای انجام مواردی که لازم است قبل از نشان داده شدن 
	{\normalsize \lr{‌View}}
	انجام شود، استفاده می‌شود. این تابع به سادگی نشان می‌دهد که 
	{\normalsize \lr{‌View}}
	مورد نظر در حال اضافه شدن به سلسله مراتب 
	{\normalsize \lr{‌View}}
	نرم‌افزار می‌باشد.
	
	\item[ ] 
	{\normalsize \lr{‌viewDidApper()}}- 
	درست بعد از اینکه 
	{\normalsize \lr{‌View}}
	مربوط به 
	{\normalsize \lr{‌ViewController}}،
	به سلسله مراتب 
	{\normalsize \lr{‌View}}
	نرم‌افزار اضافه شود، این تابع فراخوانی می‌شود. از این تابع به منظور انجام اعمالی استفاده می‌شود که،  می‌خواهیم به محض نشان دادن 
	{\normalsize \lr{‌View}}
	انجام شوند. برای مثال واکاوی داده و یا نشان دادن یک 
		{\normalsize \lr{‌Animation}}
	. این تابع به سادگی نشان می‌دهد که 
	{\normalsize \lr{‌View}}
	مورد نظر به سلسله مراتب 
	{\normalsize \lr{‌View}}
	نرم‌افزار اضافه شده است.
	
\end{itemize}
	
\section{استفاده از رابط برنامه‌نویسی نرم‌افزار {\normalsize \lr{‌Core Location}}}
	برای استفاده از تکنولوژی 
	{\normalsize \lr{‌iBeacon}}
	، از رابط برنامه‌نویسی 
	{\normalsize \lr{‌Core Location}}
	استفاده می‌شود. برای پیاده سازی دو قابلیت 
		{\normalsize \lr{‌Monitoring}}
		و 
			{\normalsize \lr{‌Ranging}}
			از کلاس 
				{\normalsize \lr{‌AppDelegate}} 
				موجود، بدلیل اینکه امکان استفاده در حالت 
					{\normalsize \lr{‌Background}}
				وجود داشته باشد، استفاده می‌شود.

در ابتدا رابط نرم‌افزاری 
	{\normalsize \lr{‌Core Location}}
	را به کلاس با قطعه کد زیر وارد می‌کنیم: 
	\begin{latin}
		\begin{verbatim}
	import CoreLocation
	
		\end{verbatim}
		
	\end{latin}	
	 پس از وارد کردن رابط نرم‌افزاری،  کلاس 
	 {\normalsize \lr{‌AppDelegate}}
	 می‌باید برای پیاده‌سازی توابع کلاس نماینده، از پروتکل 
		 {\normalsize \lr{‌CLLocationManagerDelegate}}
	پیروی کند. سپس نیاز به یک شیء برای  تعریف نماینده و یک شیء برای مشخص کردن منطقه برای 
					{\normalsize \lr{‌iBeacon}} 
	به منظور استفاده از این تکنولوژی می‌باشد. 
		\begin{latin}
		\begin{verbatim}
let locationManager = CLLocationManager()
let region = CLBeaconRegion(proximityUUID:
 NSUUID(uuidString: "163EB541-B100-4BA5-8652-EB0C513FB0F4")
 ! as UUID , identifier: "mypay")
		
		\end{verbatim}
		
	\end{latin}	
	قبل از استفاده از هریک از قابلیت‌ها، باید نماینده مشخص شود و اجازه‌ی دسترسی به 
					{\normalsize \lr{‌Location Service}}
	از کاربر باید صادر شود. بدین منظور قطعه کد زیر یک صفحه‌ی درخواست به کاربر نشان می‌دهد: 
				\begin{latin}
				\begin{verbatim}
 locationManager.requestAlwaysAuthorization()
 locationManager.delegate = self

				\end{verbatim}
				
			\end{latin}	
		این قطعه کد را در تابع 
			{\normalsize \lr{‌application}}
			استفاده می‌کنیم.		 
	
	\subsection{{\small \lr{‌Monitoring}}}
	از قابلیت 
	{\normalsize \lr{‌Monitoring}}
	تکنولوژی
	{\normalsize \lr{‌iBeacon}}
	 به منظور اطلاع از ورود و خروج کاربر از ناحیه‌ی 
	{\normalsize \lr{‌Beacon}}
	استفاده می‌شود.
	
	برای شروع کار 
	{\normalsize \lr{‌Monitoring}}
	در تابع 
	{\normalsize \lr{‌application}}
	قطعه کد زیر را وارد می‌کنیم:
	\begin{latin}
	\begin{verbatim}
  locationManager.startMonitoring(for: region)

	\end{verbatim}
	
\end{latin}		
	
زمانی که کاربر به محدوده‌ی 
	{\normalsize \lr{‌Beacon}}
	وارد شود تابع زیر فراخوانی می‌شود: 
	\begin{latin}
		\begin{verbatim}
func locationManager(CLLocationManager, didEnterRegion: CLRegion)
		\end{verbatim}
		
\end{latin}	
و زمانی که کاربر از محدوده خارج می‌شود، تابع زیر فراخوانی می‌شود: 
\begin{latin}
	\begin{verbatim}
func locationManager(CLLocationManager, didExitRegion: CLRegion)
	\end{verbatim}
\end{latin}	
	پیاده‌سازی این دو تابع به شکل زیر می‌باشد: 
	\begin{latin}
		\begin{verbatim}
 func locationManager(_ manager: CLLocationManager, 
 didEnterRegion region: CLRegion) {
locationManager.startRangingBeacons(in: self.region)
let content = UNMutableNotificationContent()
content.title = "Pay here with MyPay"
content.body = "you are close to a store"
content.badge = 12
content.sound = UNNotificationSound.default()
//        let trigger = UNTimeIntervalNotificationTrigger
(timeInterval: 5,repeats: false)
let request = UNNotificationRequest(identifier:
 "braconnotifi", content: content, trigger: nil)
let center = UNUserNotificationCenter.current()
center.add(request, withCompletionHandler: nil)
}

func locationManager(_ manager: CLLocationManager, 
didExitRegion region: CLRegion) {
defaults.set(false, forKey: "storestate")
defaults.set(nil, forKey: "storename")
defaults.set(nil, forKey: "storeid")
defaults.synchronize()
let content = UNMutableNotificationContent()
content.title = "heey!"
content.body = "you left the Beacon area"
content.badge = 12
content.sound = UNNotificationSound.default()
//        let trigger = UNTimeIntervalNotificationTrigger
(timeInterval: 5,repeats: false)
let request = UNNotificationRequest(identifier: 
"beaconnotifi", content: content, trigger: nil)
let center = UNUserNotificationCenter.current()
center.add(request, withCompletionHandler: nil)
}
		\end{verbatim}
	\end{latin}	
	زمانی که کاربر وارد محدوده‌ی 
		{\normalsize \lr{‌Beacon}}
		می‌شود، اطلاعی به کاربر به معنی ورود وی به محدوده‌ی 
			{\normalsize \lr{‌Beacon}}
			داده می‌شود. به همین شکل زمانی که کاربر از محدوده‌ی 
				{\normalsize \lr{‌Beacon}}
				خارج می‌شود اعلان دیگری ارسال می‌شود. 
				
	\subsection{{\small \lr{‌Ranging}}}
برای اطلاع از ورود و خروج کاربران از
						{\normalsize \lr{‌Monitoring}}
	استفاده شد. اما تابع مربوطه اطلاعات کافی مربوط به 
			{\normalsize \lr{‌UUID}}،
					{\normalsize \lr{‌Major}}
			و 
					{\normalsize \lr{‌Minor}}
		کشف شده را در اختیارمان قرار نمی‌دهد و به منظور بدست آوردن این مقادیر از 
				{\normalsize \lr{‌Rangin}}
				استفاده می‌شود. تابع زیر زمانی فراخوانی می‌شود که تغییری در مقدار مجاورت ایجاد شود: 
				\begin{latin}
				\begin{verbatim}
func locationManager(CLLocationManager, didRangeBeacons:
 [CLBeacon], in:CLBeaconRegion)
				\end{verbatim}
				
			\end{latin}		
پیاده‌سازی این تابع بشکل زیر می‌باشد: 
\begin{latin}
	\begin{verbatim}
	
 if beacons.count > 0 {
   let knownBeacon = beacons[0]
    notifyEntryToServer(uuid: knownBeacon.proximityUUID.uuidString, 
    major: knownBeacon.major.intValue, 
    minor: knownBeacon.minor.intValue)
    locationManager.stopRangingBeacons(in: self.region)
      }
	\end{verbatim}
	
\end{latin}		
	تابع 
					{\normalsize \lr{‌notifyEntryToServer}}
	مقادیر بدست آمده از 
						{\normalsize \lr{‌Beacon}}
						را به منظور یافتن مکان فعلی کاربر به سرور ارسال می‌کند. 
						
						پیاده‌سازی این تابع در قطعه کد زیر آمده است:‌
\begin{latin}
	\begin{verbatim}
 let defaultConfiguration = URLSessionConfiguration.default
let delegate = self
let operationQueue = OperationQueue.main
let defaultSession = URLSession(configuration:
 defaultConfiguration, delegate: 
 delegate, delegateQueue: operationQueue)

if let srvURL = URL(string: MyServer.Method.getStoreMethod) {
var srvUrlRequest = URLRequest(url: srvURL)
srvUrlRequest.httpMethod = "POST"

let body = BodyMaker()
body.appednKeyValue(key: "uuid", value: uuid)
body.appednKeyValue(key: "major", value: String(major))
body.appednKeyValue(key: "minor", value: String(minor))

let bodyString  = body.getBody()
srvUrlRequest.httpBody =
 bodyString?.data(using: String.Encoding.utf8)
let dataTask = defaultSession.dataTask(with: srvUrlRequest)
dataTask.resume()
}
	\end{verbatim}
	
\end{latin}							
در این این تابع یک درخواست 
						{\normalsize \lr{‌POST}}
	به سرور به منظور پیدا کردن مکان فرستاده می‌شود، سه مقدار 
							{\normalsize \lr{‌UUID}}،
																		{\normalsize \lr{‌Major}}
																		و 
																								{\normalsize \lr{‌Minor}}
																								به عنوان پارامتر‌ها ارسال می‌شوند. 

برای ارسال بسته‌های 
						{\normalsize \lr{‌HTTP}}
	در 
							{\normalsize \lr{‌iOS}}
					از کلاس
											{\normalsize \lr{‌URLSession}} 
						و	از دو راه می‌توان این کار را انجام داد:
\begin{itemize}
	\item[-]
	استفاده از 
							{\normalsize \lr{‌Application Handler}}
	\item[-]
	استفاده از توابع نماینده
\end{itemize}
	در این نرم‌افزار برای ارسال بسته‌ها از روش استفاده از توابع نماینده استفاده شده است. برای استفاده از این روش 
	ابتدا کلاس
							{\normalsize \lr{‌Appdelegate}}
				از پروتکل 
										{\normalsize \lr{‌URLSessionDelegate }}
										و 
									{\normalsize \lr{‌URLSessionDataDelegate}}
				تبعیت کرده، و سپس به عنوان نماینده‌ تعریف می‌شود.
	تابعی که برای دریافت پیام ارسالی از طرف سرور باید پیاده‌سازی شود، به صورت زیر می‌باشد: 
	\begin{latin}
		\begin{verbatim}
		func urlSession(_ session: URLSession, dataTask: 
		URLSessionDataTask, didReceive data: Data) {
		var serverResultCode: Int?
		var serverMetaData: String?
		var serverStoreID: Int?
		var serverStoreName: String?
		let responseData = data
		//  parse the result as JSON, since that's what the API provides
		do {
		guard let receivedData = try JSONSerialization.jsonObject(with:
		 responseData,options: []) as? [String: Any] else {
		// print("Could not get JSON from responseData as dictionary")
		return
		}
		
		guard let resutlCode = receivedData["resultcode"] as? Int else {
		// print("Could not get resultcode as int from JSON")
		return
		}
		serverResultCode = resutlCode
		guard let metaData = receivedData["metadata"] as? String else {
		// print("Could not get resultcode as int from JSON")
		return
		}
		serverMetaData = metaData
		guard let storeID = receivedData["storeid"] as? Int else {
		// print("Could not get resultcode as int from JSON")
		return
		}
		serverStoreID = storeID
		guard let storeName = receivedData["storename"] as? String else {
		// print("Could not get resultcode as int from JSON")
		return
		}
		serverStoreName = storeName
		
		} catch  {
		// print("error parsing response from POST on /getstore")
		return
		}
		if serverResultCode == 500
		{
		defaults.set(true, forKey: "storestate")
		defaults.set(serverStoreName, forKey: "storename")
		defaults.set(serverStoreID, forKey: "storeid")
		defaults.synchronize()
		print(serverMetaData!)
		  }
		 }
		\end{verbatim}
		
	\end{latin}	
	این تابع مقادر ارسالی توسط سرور را دریافت می‌کند،  آن‌ها را با استفاده از تجزیه گر 
								{\normalsize \lr{‌JSON}}
								تجزیه نموده و در پایان اطلاعات را در 
															{\normalsize \lr{‌Userdefaults}}
															ذخیره می‌کند. 

\section{ {\normalsize \lr{‌UserDefaults}}}	
کلاس
	{\normalsize \lr{‌UserDefaults}}
	یک رابط برنامه‌نویسی برای تعامل با سیستم پیش‌فرض‌ها 
							       	\LTRfootnote{system defaults}
	فراهم می‌کند. سیستم پیش‌فرض‌ها به یک نرم‌افزار اجازه می‌دهد تا خودش را مطابق با تنظیمات کاربر شخصی‌سازی کند. نرم‌افزار چنین تنظیماتی را با مقرر کردن مقادیری به یک مجموعه‌ای از پارامترها در پایگاه‌داده‌ی پیش‌فرض‌ها ذخیره می‌کند. این پارامتر‌ها به مقادیر پیش‌فرض منتسب می‌شوند به این دلیل که برای تعیین کردن وضعیت اولیه‌ی نرم‌افزار در زمان شروع استفاده می‌شوند. 
	
در پروژه از مقادیر پیش‌فرض به منظور ذخیره‌ی مقادیر احراز هویت و وضعیت نرم‌افزار مورد استفاده قرار گرفته است. 

نحوه‌ی استفاده از مقادیر پیش‌فرض بدین شکل است که ابتدا یک مورد از مقادیر پیش‌فرض گرفته می‌شود:
\begin{latin}
	\begin{verbatim}
let defaults = UserDefaults.standard	
	\end{verbatim}
	
\end{latin}	
	سپس به شکل زیر پارامترها و مقادیر آن ها به همدیگر منتسب می‌شوند:
\begin{latin}
	\begin{verbatim}
defaults.set(true, forKey: "storestate")
defaults.set(serverStoreName, forKey: "storename")
defaults.set(serverStoreID, forKey: "storeid")
	\end{verbatim}
	
\end{latin}		
	برای واکاوی مقادیر به شکل زیر عمل می‌شود: 
	\begin{latin}
		\begin{verbatim}
defaults.bool(forKey: "storestate") 
		\end{verbatim}
		
	\end{latin}	
	
\section{{\normalsize \lr{‌Model}}}
	همانظور که در بخش 
	\ref{mvc}
	ذکر شد، یکی از مؤلفه‌های الگوی طراحی 
	{\normalsize \lr{‌MVC}}،
	{\normalsize \lr{‌Model}}ها 
	می‌باشند که وظیفه‌ی ذخیره‌ی اطلاعات کاربر و نگهداری وضعیت نرم‌افزار را بر عهده دارند. 

در پروژه برای ذخیره‌سازی کارت‌های بانکی نیازمند 
{\normalsize \lr{‌Model}}
ها می‌باشیم که از قابلیت 
{\normalsize \lr{‌NSCoding}}
استفاده شده‌است. بدین منظور کلاس 
{\normalsize \lr{‌Card.swift}}
به عنوان 
{\normalsize \lr{‌Model}}
و برای ذخیره‌سازی کارت‌های بانکی به شکل زیر پیاده‌سازی شده است:‌
	\begin{latin}
	\begin{verbatim}
class Card: NSObject,NSCoding{
//MARK: Properties
var cardNumber: Int? = nil
var cardName: String? = nil
var expirationDate: String? = nil
var cvv2: Int? = nil
var bankName: String? = nil

struct Propertykey {
static let cardNumberKey = "cardNumber"
static let cardNameKey = "cardName"
static let expirationDateKey = "expirationDate"
static let cvv2Key = "cvv2"
static let bankNameKey = "bankName"
   }

//Initialization
init(num: Int?,crdName: String?,exprdate: String?,cvv2: Int?
, bankName: String?)
   {
self.cardNumber = num
self.cardName = crdName
self.expirationDate = exprdate
self.cvv2 = cvv2
//        if let theBankName = bankName{
//            self.bankName = theBankName
//         }
   }
//MARK: Archiving Paths
static let DocumentsDirectory = FileManager().urls(for: 
.documentDirectory, in: .userDomainMask).first!
static let ArchiveURL =
 DocumentsDirectory.appendingPathComponent("mypaycards")

//MARK: NSCoding
func encode(with aCoder: NSCoder) {
aCoder.encode(cardNumber,forKey: Propertykey.cardNumberKey)
aCoder.encode(cardName,forKey: Propertykey.cardNameKey)
aCoder.encode(expirationDate, forKey:
 Propertykey.expirationDateKey)
aCoder.encode(cvv2, forKey: Propertykey.cvv2Key)
//        aCoder.encode(bankName, forKey:
 Propertykey.bankNameKey)
   }

required convenience init?(coder aDecoder: NSCoder) {
let num = aDecoder.decodeObject(forKey: 
Propertykey.cardNumberKey) as? Int
let crdName = aDecoder.decodeObject(forKey:
 Propertykey.cardNameKey) as? String
let exprdate = aDecoder.decodeObject(forKey: 
Propertykey.expirationDateKey) as? String
let cvv2 = aDecoder.decodeObject(forKey: 
Propertykey.cvv2Key) as? Int
let bankname = aDecoder.decodeObject(forKey:
 Propertykey.bankNameKey) as? String
self.init(num: num,crdName: crdName,exprdate: 
exprdate,cvv2: cvv2,bankName: bankname)
      }
   }
	\end{verbatim}
	
\end{latin}		
با استفاده از روش
{\normalsize \lr{‌NSCoding}}
داده به شکل مقرر کردن مقادر به خصوصیت‌هایشان 
				       	\LTRfootnote{Property}		
به یک کلید خاص ذخیره می‌شوند. یک کلید یک رشته‌ی ساده است. برای سهولت استفاده این رشته‌ها در قالب یک 
{\normalsize \lr{‌Sruct}}
				       	درست می‌شوند. برای ذخیره‌سازی با استفاده از این روش، تابع 
				       	{\normalsize \lr{‌encode(with : NSCoder)}}
	به منظور کدگذاری داده، پیاده‌سازی می‌شود و به منظور واکاوی تابع مقداردهی اولیه‌ی 
					       	\LTRfootnote{init method}		
	مناسب به منظور کدگشایی داده‌ها پیاده‌سازی می‌شود. 
	
	
	
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	\newpage
	\def\bibname{مراجع}
	\bibliographystyle{ieeetr}
	\bibliography{references}
	
	\newpage
	
	\begin{latin}
		
		\section*{Abstract}
		{
			\Large
			With security problems in electronic payment field, using digital wallet 
			is significantly considerable. Because current payment methods expose essential card information, the most primary goals of digital wallets are as follows:  preserving payment information, making transactions more secure, as well as payment facility. 
			
			\noindent
			In early chapters, tokenisation technology will be reviewed which has primary role in securing digital wallets. In remaining chapters, different parts of the implemented project will be investigated. 
			
			\noindent
			Finally, in this thesis, we have implemented an iBeacon based payment system.
			
			
			
			\vspace*{1.5cm}
			
			\noindent
			keywords: Tokenisation, iBeacon, Electronic Payment, Digital Wallet 
		}
		
		
	\end{latin}	
	
	\newpage
	
	
	\begin{latin}
		\begin{figure}
			\centering
			\includegraphics[height=3cm]{image2/semnanunieng}
		\end{figure}

		\begin{center}
		
		\textbf{\Large Faculty of Electrica \&  Computer Engineering}
		
		\vspace*{1cm}
		
		\textbf{\huge B.Sc. Thesis in Computer Software Engineering}
		
		\vspace*{1.3cm}
		
		\textbf{\huge Technical analysis over digital wallet }			
		
		\vspace*{0.3cm}
					
		\textbf{\huge and designing and implementing}			
		
		\vspace*{0.3cm}
		
		\textbf{\huge a sample payment}			
					
		\vspace*{1.3cm}			
		
		\textbf{\Large By:}
		
		\vspace*{0.5cm}			
		
		\textbf{\huge Mohammad Hesam Modaberi}
		
		\vspace*{1.5cm}
					
		\textbf{\Large Supervisor:}
		
		\vspace*{0.5cm}
		
		\textbf{\huge Dr. Morteza Dorrigiv}
		
		\vspace*{3cm}
		
		\textbf{\LARGE February 2017}		
				
					
		\end{center}
		
	\end{latin}
	
\end{document}